/* ******** STM32CustomBootloader - FastBit Embedded Brain Academy course on Udemy ********
 *
 *		STM32F446XX Memory Organization
 *	. Internal Flash Memory (aka Embedded Flash memory) of 512kB
 *	. Internal SRAM1 of 112kB
 *	. Internal SRAM2 of 16kB
 *	. System Memory (ROM) of 30kB
 *	. OTP memory of 528 bytes
 *	. Option bytes memory of 16bytes
 *	. Backup RAM of 4kB
 *
 *	Internal Flash Memory:
 *	512kB, 0x0800 0000 - 0x0807 FFFF
 *	Used to store application code and read only data of the program, and vector table
 *	Non volatile
 *
 *	Internal SRAM1:
 *	112kB, 0x2000 0000 - 0x2001 BFFF
 *	Used to store application global data, static variables, Stack and Heap purposes
 *	Volatile
 *	Can also execute code from this memory
 *
 *	Internal SRAM2:
 *	16kB, 0x2001 C000 - 0x2001 FFFF
 *	Used to store your application global data, static variables, Stack and Heap purposes
 *	Volatile
 *	Can also execute code from this memory
 *
 *	System Memory (ROM):
 *	30kB, 0x1FFF 0000 - 0x1FFF 77FF
 *	All of the ST MCUs store the Bootloader in this memory
 *	Read-only memory
 *	By default, the MCU will not execute any code from this memory but it can be configured to boot
 *	or execute bootloader from this memory.
 *
 *						Flash Module Organization
 *	Block			Name			Block base addresses				Size
 *	Main Memory		Sector 0		0x0800 0000 - 0x0800 3FFF			16kB
 *	    ...			Sector 1		0x0800 4000 - 0x0800 7FFF			16kB
 *	    aka			Sector 2		0x0800 8000 - 0x0800 BFFF			16kB
 *	    ...			Sector 3		0x0800 C000 - 0x0800 FFFF			16kB
 *  	User Flash		Sector 4		0x0801 0000 - 0x0801 FFFF			64kB
 *	    ...			Sector 5		0x0802 4000 - 0x0803 FFFF			128kB
 *	   512kB		Sector 6		0x0804 8000 - 0x0805 FFFF			128kB
 *	    ...			Sector 7		0x0806 C000 - 0x0807 FFFF			128kB
 *  ------System Memory------				0x1FFF 0000 - 0x1FFF 77FF			30kB
 *  --------OTP Area---------				0x1FFF 7800 - 0x1FFF 7A0F			528kB
 *  ------Option Bytes-------				0x1FFF C000 - 0x1FFF C00F			16B
 *
 *
 *
 *  	Reset Sequences of a Microcontroller: Discussion
 *  1. When you reset the MCU, the PC of the processor is loaded with the value 0x0000 0000
 *  2. Then processor reads the value @ memory location 0x0000 0000 into MSP
 *  	MSP = value@0x0000 0000
 *  	MSP is a Main Stack pointer register
 *  	That means, processor first initializes the stack pointer register
 *  3. Processor reads the value @ memory location 0x0000 0004 into PC
 *     	That value is the address of the reset handler.
 *  4. PC jumps to the reset handler
 *  5. A reset handler is just a C or assembly function written by you to carry out any initializations required.
 *  6. From the reset handler, you call the main() function of the application
 *
 *	All ARM Cortex M Based MCUs right after reset:
 *	1) Load value @ memory addr. 0x0000 0000 to MSP
 *	2) Load value @ memory addr. 0x0000 0004 to PC (Value = Addr of the reset handler)
 *
 *	In STM32 MCU:
 *	1) MSP value stored at 0x0800 0000
 *	2) Vector table starts from 0x0800 0004
 *	3) Address of the reset handler found at 0x0800 0004
 *
 *	So it makes sense that we would need to somehow link 0x0800 0000 to 0x0000 0000 with Memory Aliasing
 *
 *
 *		Boot Configuration of STM32F446xx
 *
 *						Boot Modes
 *	Boot Mode Sel. Pins			Boot Mode		Aliasing
 *	Boot1 		  Boot0
 *    x				0		Main Flash memory	Main Flash memory is selected as the boot area
 *    0				1		System memory		System memory is selected as the boot area
 *    1				1		Embedded SRAM		Embedded SRAM is selected as the boot area
 *
 * USART2 is used for VirtualCOM ST-LINK connection to STM32F446RE. It cannot be used for Boot Mode, use USART1 or USART3 or other 
 *    supported communications listed in app notes.
 * USART3_RX pin PC11, USART3_TX pin PC10
 *
 * 	Bootloader Transport:
 * Bootloader <-> Virtual COM port (USART2) <-> To/From PC
 * 			or
 * Bootloader <-> Debug port (USART3) -> to PC
 *
 * Debug port can be used to print debug messages from Bootloader code. USB to UART converter is required to connect to PC (optional)
 *
 *  	Bootloader: Code Placement in Flash
 * System Memory -- ROM (30kB) - ST Bootloader
 * Main Memory -- Sector0 (16kB) & Sector1 (16kB) - Our Bootloader
 * Sectors2-7 will be used for storing user application
 *
 *	Bootloader Supported Commands:
 * Host Sends			 Command Code	Bootloader Replies						Notes
 * -----------------------------------------------------------------------------------------------------------------------------
 * BL_GET_VER			 0x51			Bootloader version number (1byte)		Read the bootloader version from MCU
 * BL_GET_HELP			 0x52			All supported Command codes (10bytes)	Print the supported commands of the bootloader
 * BL_GET_CID			 0x53			Chip identification number (2bytes)		Read the MCU chip identification number
 * BL_GET_RDP_STATUS	 0x54			Returns FLASH Read Prot. level (1byte) 	Read the FLASH Read Protection level
 * BL_GO_TO_ADDR		 0x55			Success or Error Code (1byte)			Jump bootloader to specified address.
 * BL_FLASH_ERASE		 0x56			Success or Error Code (1byte)			Mass erase or sector erase of the user flash.
 * BL_MEM_WRITE			 0x57			Success or Error Code (1byte)			Write data into different memories of the MCU
 * BL_ENDIS_RW_PROTECT	 0x58			Success or Error Code (1byte)			Enable/disable read/write protect on different sectors of the user flash.
 * BL_MEM_READ			 0x59			Memory contents of request len			Read data from different memories of the microcontroller.
 * BL_READ_SECTOR_STATUS 0x5A			All sector statuses (2Bytes)			Read all of the sector protection statuses.
 * BL_OTP_READ			 0x5B			OTP contents							Read the OTP contents.
 *
 * 	Host-Bootloader Communication
 * Host -> Command Packet -> MCU (Bootloader)
 * Host <- ACK/NACK + Length to follow (2bytes) <- MCU (Bootloader)
 * Host <- Reply (of "length to follow" bytes) <- MCU (Bootloader)
 *
 *	Request Data Frame Formats:
 * BL_GET_VER
 * Length to follow (1Byte : = N-1 Bytes of Request Packet) + Command Code (1 Byte) + CRC (4 Bytes) = 6 Bytes Total (so, N=6)
 *
 * BL_GET_HELP
 * Length to follow (1Byte : = N-1 Bytes of Request Packet) + Command Code (1 Byte) + CRC (4 Bytes) = 6 Bytes Total (so, N=6)
 *
 * BL_GET_CID
 * Length to follow (1Byte : = N-1 Bytes of Request Packet) + Command Code (1 Byte) + CRC (4 Bytes) = 6 Bytes Total (so, N=6)
 * 
 * BL_GO_TO_ADDR
 * Length to follow (1Byte : = N-1 Bytes) + Command Code (1Byte) + Memory Address (LE) (4Bytes) + CRC (4Bytes) = 10 Bytes Total (N=10)
 *
 * BL_FLASH_ERASE
 * Length to follow (1Byte) + Command Code (1Byte) + Sector Number (1Byte) + Number of Sectors (1Byte) + CRC (4Bytes) = 8 Bytes Total (N=8)
 *
 * BL_MEM_WRITE
 * Length to follow (1Byte) + Command Code (1Byte) + Base Memory Address (LE) (4Bytes) + Payload Length (X) (1Byte) + Payload (X Bytes) + ..
 *																								.. + CRC (4Bytes) = 11 + X Bytes Total (N=11+X)
 *
 * BL_MEM_READ
 * Length to follow (1Byte) + Command Code (1Byte) + Base Memory Address (LE) (4Bytes) + Len (1Byte) + CRC (4Bytes) = 11 Bytes Total (N=11)
 *
 * BL_EN_R_W_PROTECT
 * Length to follow (1Byte) + Command Code (1Byte) + Sector Details (1Byte) + Protection Mode (1Byte) + CRC (4Bytes) = 8 Bytes Total (N=8)
 *
 * BL_DIS_R_W_PROTECT
 * Length to follow (1Byte) + Command Code (1Byte) + CRC (4Bytes) = 6 Bytes Total
 *
 * BL_READ_SECTOR_STATUS
 * Length to follow (1Byte) + Command Code (1Byte) + CRC (4Bytes) = 6 Bytes Total
 *
 *
 *   Option Bytes in memory are used to configure write-protection and other security levels (R,W,Erase) of memory sectors, amongst other things.
 *   RDP (Read protection option byte) settings Bit 15:8 :
 *	0xAA : Level 0, no protection
 *	0xCC : Level 2, chip protection (debug and boot from RAM features disabled)
 *	Others : Level 1, read protection of memories (debug features limited)
 *	
 *   If Level 2: (debug/chip protection disabled) by writing 0xCC to the RDP option byte is set, the following is true:
 *   All protections provided by level 1 are active. Booting from RAM or system memory bootloader is no longer allowed.
 *   JTAG, SWV, ETM, and boundary scan are disabled. User option bytes can no longer be changed. When booting from Flash memory,
 *   accesses (read, erase and program) to Flash memory from user code are allowed.
 *
 *   Memory read protection Level 2 is an irreversible operation. When Level 2 is activated, the level of protection cannot be decreased to Level 0 or 
 *   Level 1. The JTAG port is permanently disabled when Level 2 is active (acting as a JTAG fuse).
 *
 *   Changing from RDP Level 1 to Level 0 will erase the whole flash memory (can make a command do that).

0x080081DC User App Reset Handler  (Go to debug mode in keil, and search 0x08008000 in memory windor. You'll see 0x080081DD as the next word after address
of MSP (also R12), so subtract 4 and you get 0x080081DC for address of Reset Handler)


In order to change/modify FLASH contents, you have to "erase" first before programming a new value. In order to erase, you simply write 0xFF to the byte. 
You cannot directly change 0xAB to 0xCD; instead you have to do 0xAB -> 0xFF -> 0xCD.

To erase a FLASH sector,
1: Check that no flash memory operation is ongoing by checking the BSY bit in the FLASH_SR register.
2: Set the SER bit and select the sector out of the 7 sectors in the main memory block you wish to erase (SNB) in the FLASH_CR register.
3: Set the STRT bit in the FLASH_CR register
4: Wait for the BSY bit to be cleared

To Mass Erase:
1: Check that no Flash memory operation is ongoing by checking the BSY bit in the FLASH_SR register
2: Set the MER bit in the FLASH_CR register
3: Set the STRT bit in the FLASH_CR register
4: Wait for the BSY bit to be cleared
Note: If MER and SER bits are both set in the FLASH_CR register, mass erase is performed. If both MER and SER bits are reset and the STRT bit is set, 
an unpredictable behavior may occur without generating any error flag. This condition should be forbidden.

Standard Programming:
1: Check that no main Flash memory operation is ongoing by checking the BSY bit in the FLASH_SR register
2: Set the PG bit in the FLASH_CR register
3: Perform the data write operation(s) to the desired memory address (inside main memory block or OTP area)
	- Byte access in case of x8 parallelism
	- Half-word access in case of x16 parallelism
	- Word access in case of x32 parallelism
	- Double word access in case of x64 parallelism
4: Wait for the BSY bit to be cleared
Note: Successive write operations are possible without the need of an erase operation when changing bits from 1 to 0. Writing 1 requires a flash 
      memory erase operation. If an erase and a program operation are requested simultaneously, the erase operation is performed first.

Unlocking the Flash control register:
After reset, write is not allowed in the Flash control register (FLASH_CR) to protect the Flash memory against possible unwanted operations due, 
for example, to electric disturbances.
The following sequence is used to unlock this register:
1. Write KEY1 = 0x45670123 in the Flash key register (FLASH_KEYR)
2. Write KEY2 = 0xCDEF89AB in the Flash key register (FLASH_KEYR)
Any wrong sequence will return a bus error and lock up the FLASH_CR register until the next reset.
The FLASH_CR register can be locked again by software by setting the LOCK bit in the FLASH_CR register.


Bits 7:0 of nWRP (Flash memory write protection option bytes) for Sectors 0 to 7
If SPRMOD is reset (default value), 0: Write protection active on sector i. 1: Write protection not active on sector i.
If SPRMOD is set (active), 0: PCROP protection not active on sector i. 1: PCROP protection active on sector i.

SPRMOD: Selection of Protection Mode of nWPRi bits
0: nWPRi bits used for sector i write protection (Default)
1: nWPRi bits used for sector i PCROP protection (Sector)

PCROP : Proprietary code readout protection

Programming User Option Bytes:
To run any operation on this sector, the option lock bit (OPTLOCK) in the FLASH option control register (FLASH_OPTCR) must be cleared. Top be allowed 
to clear this bit, you have to perform the following sequence:
1. Write OPTKEY1 = 0x08192A3B in the Flash option key register (FLASH_OPTKEYR)
2. Write OPTKEY2 = 0x4C5D6E7F in the Flash option key register (FLASH_OPTKEYR)
The user option bytes can be protected against unwanted erase/program operations by setting the OPTLOCK bit by software.

Modifying User Option Bytes:
To modify the user option value, follow the sequence below:
1. Check that no Flash memory operation is ongoing by checking the BSY bit in the FLASH_SR register.
2. Write the desired option value in the FLASH_OPTCR register.
3. Set the option start bit (OPTSTRT) in the FLASH_OPTCR register.
4. Wait for the BSY bit to be cleared.

Note: The value of an option is automatically modified by first erasing the user configuration sector and then programming all the option bytes with 
the values contained in the FLASH_OPTCR register.

Read Protection (RDP)

/****************************************************************************************************/
									bootloader_STM32F446x
/****************************************************************************************************/
//////////////////////////////// main.h ////////////////////////////////
/* USER CODE BEGIN Header */
/**
  ******************************************************************************
  * @file           : main.h
  * @brief          : Header for main.c file.
  *                   This file contains the common defines of the application.
  ******************************************************************************
  * @attention
  *
  * <h2><center>&copy; Copyright (c) 2021 STMicroelectronics.
  * All rights reserved.</center></h2>
  *
  * This software component is licensed by ST under BSD 3-Clause license,
  * the "License"; You may not use this file except in compliance with the
  * License. You may obtain a copy of the License at:
  *                        opensource.org/licenses/BSD-3-Clause
  *
  ******************************************************************************
  */
/* USER CODE END Header */

/* Define to prevent recursive inclusion -------------------------------------*/
#ifndef __MAIN_H
#define __MAIN_H

#ifdef __cplusplus
extern "C" {
#endif

/* Includes ------------------------------------------------------------------*/
#include <stdint.h>

/* Private includes ----------------------------------------------------------*/
/* USER CODE BEGIN Includes */
#include "stm32f4xx_hal.h"

/* USER CODE END Includes */

/* Exported types ------------------------------------------------------------*/
/* USER CODE BEGIN ET */

/* USER CODE END ET */

/* Exported constants --------------------------------------------------------*/
/* USER CODE BEGIN EC */

/* USER CODE END EC */

/* Exported macro ------------------------------------------------------------*/
/* USER CODE BEGIN EM */

/* USER CODE END EM */

/* Exported functions prototypes ---------------------------------------------*/
void Error_Handler(void);

/* USER CODE BEGIN EFP */
/* Bootloader function prototypes */
void bootloader_uart_read_data(void);
void bootloader_jump_to_user_app(void);

void bootloader_handle_getver(uint8_t *bl_rx_buffer);
void bootloader_handle_gethelp(uint8_t *bl_rx_buffer);
void bootloader_handle_getcid(uint8_t *bl_rx_buffer);
void bootloader_handle_getrdp(uint8_t *bl_rx_buffer);
void bootloader_handle_go_to_addr(uint8_t *bl_rx_buffer);
void bootloader_handle_flash_erase(uint8_t *bl_rx_buffer);
void bootloader_handle_mem_write(uint8_t *bl_rx_buffer);
void bootloader_handle_en_rw_protect(uint8_t *bl_rx_buffer);
void bootloader_handle_dis_rw_protect(uint8_t *bl_rx_buffer);
void bootloader_handle_mem_read(uint8_t *bl_rx_buffer);
void bootloader_handle_read_sector_protection_status(uint8_t *bl_rx_buffer);
void bootloader_handle_read_otp(uint8_t *bl_rx_buffer);

void bootloader_send_ack(uint8_t command_code, uint8_t follow_len);
void bootloader_send_nack(void);

uint8_t bootloader_verify_crc(uint8_t *pData, uint32_t len, uint32_t crc_host);
void bootloader_uart_write_data(uint8_t *pBuffer, uint32_t len);
uint8_t get_bootloader_version(void);
uint16_t get_mcu_chip_id(void);
uint8_t get_flash_rdp_level(void);
uint8_t verify_address(uint32_t go_to_address);
uint8_t execute_flash_erase(uint8_t sector_number, uint8_t number_of_sectors);
uint8_t execute_mem_write(uint8_t *pBuffer, uint32_t mem_address, uint32_t len);
uint8_t configure_flash_sector_rw_protection(uint8_t sector_details, uint8_t protection_mode, uint8_t disable);
uint16_t read_OB_rw_protection_status(void);

/* Bootloader Commands */
#define BL_GET_VER										0x51  //Read Bootloader Version from MCU
#define BL_GET_HELP										0x52  //Print Commands Supported by the Bootloader
#define BL_GET_CID										0x53  //Read the MCU Chip ID Number
#define BL_GET_RDP_STATUS								0x54  //Read the FLASH Read Protection Level
#define BL_GO_TO_ADDR									0x55  //Jump Bootloader to Specified Address
#define BL_FLASH_ERASE									0x56  //Mass Erase or Sector Erase of User Flash
#define BL_MEM_WRITE									0x57  //Write Data into Different Memories of MCU
#define BL_EN_RW_PROTECT								0x58  //Enable Read/Write Protect on Different Sectors of User Flash
#define BL_MEM_READ										0x59  //Read Data from Different Memories of the MCU
#define BL_READ_SECTOR_P_STATUS							0x5A  //Used to Read All the Sector Protection Statuses
#define BL_OTP_READ										0x5B  //Used to Read the OTP Contents
#define BL_DIS_RW_PROTECT								0x5C  //Disable all sector read/write protection 

/* ACK and NACK bytes */
#define BL_ACK 											0xA5
#define BL_NACK 										0x7F

#define VERIFY_CRC_SUCCESS								0
#define VERIFY_CRC_FAIL									1

#define ADDR_VALID										0x00
#define ADDR_INVALID									0x01

#define INVALID_SECTOR 									0x04

#define SRAM1_SIZE										112*1024			//STM32F446RE: 112kB of SRAM1
#define SRAM1_END										(SRAM1_BASE + SRAM1_SIZE)
#define SRAM2_SIZE										16*1024				//STM32F446RE: 16kB of SRAM2
#define SRAM2_END										(SRAM2_BASE + SRAM2_SIZE)
#define FLASH_SIZE										512*1024			//STM32F446RE: 512kB of FLASH
#define BKPSRAM_SIZE									4*1024		 	 	//STM32F446RE: 4kB of Backup SRAM
#define BKPSRAM_END										(BKPSRAM_BASE + BKPSRAM_SIZE)		


//Version 1.0
#define BL_VERSION										0x10

/* USER CODE END EFP */

/* Private defines -----------------------------------------------------------*/
#define B1_Pin 											GPIO_PIN_13
#define B1_GPIO_Port 									GPIOC
#define USART_TX_Pin 									GPIO_PIN_2
#define USART_TX_GPIO_Port 								GPIOA
#define USART_RX_Pin 									GPIO_PIN_3
#define USART_RX_GPIO_Port 								GPIOA
#define LD2_Pin 										GPIO_PIN_5
#define LD2_GPIO_Port 									GPIOA
#define TMS_Pin 										GPIO_PIN_13
#define TMS_GPIO_Port									GPIOA
#define TCK_Pin 										GPIO_PIN_14
#define TCK_GPIO_Port									GPIOA
#define SWO_Pin 										GPIO_PIN_3
#define SWO_GPIO_Port 									GPIOB

#define FLASH_SECTOR2_BASE_ADDRESS 						0x08008000U

/* USER CODE BEGIN Private defines */
/* USER CODE END Private defines */

#ifdef __cplusplus
}
#endif

#endif /* __MAIN_H */

/************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/

//////////////////////////////// main.c ////////////////////////////////
/**
  ******************************************************************************
  * @file           : main.c
  * @brief          : Main program body
  ******************************************************************************
  * @attention
  *
  * <h2><center>&copy; Copyright (c) 2021 STMicroelectronics.
  * All rights reserved.</center></h2>
  *
  * This software component is licensed by ST under BSD 3-Clause license,
  * the "License"; You may not use this file except in compliance with the
  * License. You may obtain a copy of the License at:
  *                        opensource.org/licenses/BSD-3-Clause
  *
  ******************************************************************************
  */
/* USER CODE END Header */
/* Includes ------------------------------------------------------------------*/
#include <stdarg.h>
#include <string.h>
#include <stdio.h>
#include <stdint.h>

/* Private includes ----------------------------------------------------------*/
/* USER CODE BEGIN Includes */
#include "main.h"

/* USER CODE END Includes */

/* Private typedef -----------------------------------------------------------*/
/* USER CODE BEGIN PTD */

/* USER CODE END PTD */

/* Private define ------------------------------------------------------------*/
/* USER CODE BEGIN PD */
/* USER CODE END PD */

/* Private macro -------------------------------------------------------------*/
/* USER CODE BEGIN PM */
//enable this line to get debug messages over debug uart
//#define BL_DEBUG_MSG_EN

/* USER CODE END PM */

/* Private variables ---------------------------------------------------------*/
/* USER CODE BEGIN PV */
CRC_HandleTypeDef hcrc;

UART_HandleTypeDef huart2;
UART_HandleTypeDef huart3;

#define D_UART &huart3
#define C_UART &huart2

uint8_t supported_commands[] = {
																BL_GET_VER, 
																BL_GET_HELP,
																BL_GET_CID,
																BL_GET_RDP_STATUS,
																BL_GO_TO_ADDR, 
																BL_FLASH_ERASE, 
																BL_MEM_WRITE, 
																BL_READ_SECTOR_P_STATUS };

/* USER CODE END PV */

/* Private function prototypes -----------------------------------------------*/
void SystemClock_Config(void);
static void MX_GPIO_Init(void);
static void MX_USART2_UART_Init(void);
static void MX_CRC_Init(void);
static void MX_USART3_UART_Init(void);
																
/* USER CODE BEGIN PFP */
static void printmsg(char *format, ...);
/* USER CODE END PFP */

/* Private user code ---------------------------------------------------------*/
/* USER CODE BEGIN 0 */
char somedata[] = "Hello from Bootloader\r\n";

#define BL_RX_LEN 200
uint8_t bl_rx_buffer[BL_RX_LEN];

/* USER CODE END 0 */

/**
  * @brief  The application entry point.
  * @retval int
  */
int main(void)
{
  /* USER CODE BEGIN 1 */

  /* USER CODE END 1 */

  /* MCU Configuration--------------------------------------------------------*/

  /* Reset of all peripherals, Initializes the Flash interface and the Systick. */
  HAL_Init();

  /* USER CODE BEGIN Init */

  /* USER CODE END Init */

  /* Configure the system clock */
  SystemClock_Config();

  /* USER CODE BEGIN SysInit */

  /* USER CODE END SysInit */

  /* Initialize all configured peripherals */
  MX_GPIO_Init();
  MX_USART2_UART_Init();
  MX_CRC_Init();
  MX_USART3_UART_Init();
  /* USER CODE BEGIN 2 */
	
	if(HAL_GPIO_ReadPin(B1_GPIO_Port, B1_Pin) == GPIO_PIN_RESET) {
		printmsg("BL_DEBUG_MSG: Button is pressed .. going to BL mode\n\r");
		//we should continue in bootloader mode
		bootloader_uart_read_data();
		
	} else {
		printmsg("BL_DEBUG_MSG: Button is not pressed .. executing user app\n\r");
		bootloader_jump_to_user_app();
	}
}

void bootloader_uart_read_data(void) {
	
	uint8_t rcv_len = 0;
	
	while(1) {
		memset(bl_rx_buffer, 0, 200);
		
		//here we will read and decode the commands coming from host
		
		//Read first byte (Length) of data packet
		HAL_UART_Receive(C_UART, bl_rx_buffer, 1, HAL_MAX_DELAY);
		rcv_len = bl_rx_buffer[0];
		
		//Read the rest of the data packet
		HAL_UART_Receive(C_UART, &bl_rx_buffer[1], rcv_len, HAL_MAX_DELAY);
		
		//command codes
		switch(bl_rx_buffer[1]) {
			case BL_GET_VER:
				bootloader_handle_getver(bl_rx_buffer);
				break;
			
			case BL_GET_HELP:
				bootloader_handle_gethelp(bl_rx_buffer);
				break;
			
			case BL_GET_CID:
				bootloader_handle_getcid(bl_rx_buffer);
				break;
			
			case BL_GET_RDP_STATUS:
				bootloader_handle_getrdp(bl_rx_buffer);
				break;
			
			case BL_GO_TO_ADDR:
				bootloader_handle_go_to_addr(bl_rx_buffer);
				break;
			
			case BL_FLASH_ERASE:
				bootloader_handle_flash_erase(bl_rx_buffer);
				break;
			
			case BL_MEM_WRITE:
				bootloader_handle_mem_write(bl_rx_buffer);
				break;
					
			case BL_EN_RW_PROTECT:
				bootloader_handle_en_rw_protect(bl_rx_buffer);
				break;
			
			case BL_DIS_RW_PROTECT:
				bootloader_handle_dis_rw_protect(bl_rx_buffer);
				break;
			
			case BL_MEM_READ:
				bootloader_handle_mem_read(bl_rx_buffer);
				break;
			
			case BL_READ_SECTOR_P_STATUS:
				bootloader_handle_read_sector_protection_status(bl_rx_buffer);
				break;
						
			case BL_OTP_READ:
				bootloader_handle_read_otp(bl_rx_buffer);
				break;
									
			default:
				printmsg("BL_DEBUG_MSG: Invalid command code received from host\n\r");
				break;
		}	
	}
}

void bootloader_jump_to_user_app(void) {
	//just a function pointer to hold the address of the reset handler of the user app
	void (*app_reset_handler)(void);
	printmsg("BL_DEBUG_MSG: bootloader_jump_to_user_app\n\r");
	
	//1. configure the MSP by reading the value from the base address of Sector 2
	uint32_t msp_value = *(volatile uint32_t*)FLASH_SECTOR2_BASE_ADDRESS;
	printmsg("BL_DEBUG_MSG: MSP value : %#x\n\r", msp_value);
	
	//This function comes from CMSIS
	__set_MSP(msp_value);
	
	//SCB->VTOR = FLASH_SECTOR1_BASE_ADDRESS
	
	//2. Now fetch the reset handler address of the user application from the location FLASH_SECTOR2_BASE_ADDRESS+4
	uint32_t resethandler_address = *(volatile uint32_t*)(FLASH_SECTOR2_BASE_ADDRESS + 4);
	app_reset_handler = (void*)resethandler_address;
	printmsg("BL_DEBUG_MSG: app reset handler addr : %#x\n\r", app_reset_handler);
	
	//3. jump to the reset handler of the user application
	app_reset_handler();
	
}

/* prints formatted string to console over UART */
void printmsg(char *format, ...) {
#ifdef BL_DEBUG_MSG_EN
	char str[80];
	
	/* Extract the argument list using VA APIs */
	va_list args;
	va_start(args, format);
	vsprintf(str, format, args);
	HAL_UART_Transmit(D_UART, (uint8_t*)str, strlen(str), HAL_MAX_DELAY);
	va_end(args);
#endif
}

/**
  * @brief System Clock Configuration
  * @retval None
  */
void SystemClock_Config(void)
{
  RCC_OscInitTypeDef RCC_OscInitStruct = {0};
  RCC_ClkInitTypeDef RCC_ClkInitStruct = {0};

  /** Configure the main internal regulator output voltage
  */
  __HAL_RCC_PWR_CLK_ENABLE();
  __HAL_PWR_VOLTAGESCALING_CONFIG(PWR_REGULATOR_VOLTAGE_SCALE3);
  /** Initializes the RCC Oscillators according to the specified parameters
  * in the RCC_OscInitTypeDef structure.
  */
  RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSI;
  RCC_OscInitStruct.HSIState = RCC_HSI_ON;
  RCC_OscInitStruct.HSICalibrationValue = RCC_HSICALIBRATION_DEFAULT;
  RCC_OscInitStruct.PLL.PLLState = RCC_PLL_NONE;
  if (HAL_RCC_OscConfig(&RCC_OscInitStruct) != HAL_OK)
  {
    Error_Handler();
  }
  /** Initializes the CPU, AHB and APB buses clocks
  */
  RCC_ClkInitStruct.ClockType = RCC_CLOCKTYPE_HCLK|RCC_CLOCKTYPE_SYSCLK
                              |RCC_CLOCKTYPE_PCLK1|RCC_CLOCKTYPE_PCLK2;
  RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_HSI;
  RCC_ClkInitStruct.AHBCLKDivider = RCC_SYSCLK_DIV1;
  RCC_ClkInitStruct.APB1CLKDivider = RCC_HCLK_DIV2;
  RCC_ClkInitStruct.APB2CLKDivider = RCC_HCLK_DIV1;

  if (HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_0) != HAL_OK)
  {
    Error_Handler();
  }
}

/**
  * @brief CRC Initialization Function
  * @param None
  * @retval None
  */
static void MX_CRC_Init(void)
{

  /* USER CODE BEGIN CRC_Init 0 */

  /* USER CODE END CRC_Init 0 */

  /* USER CODE BEGIN CRC_Init 1 */

  /* USER CODE END CRC_Init 1 */
  hcrc.Instance = CRC;
  if (HAL_CRC_Init(&hcrc) != HAL_OK)
  {
    Error_Handler();
  }
  /* USER CODE BEGIN CRC_Init 2 */

  /* USER CODE END CRC_Init 2 */

}

/**
  * @brief USART2 Initialization Function
  * @param None
  * @retval None
  */
static void MX_USART2_UART_Init(void)
{

  /* USER CODE BEGIN USART2_Init 0 */

  /* USER CODE END USART2_Init 0 */

  /* USER CODE BEGIN USART2_Init 1 */

  /* USER CODE END USART2_Init 1 */
  huart2.Instance = USART2;
  huart2.Init.BaudRate = 115200;
  huart2.Init.WordLength = UART_WORDLENGTH_8B;
  huart2.Init.StopBits = UART_STOPBITS_1;
  huart2.Init.Parity = UART_PARITY_NONE;
  huart2.Init.Mode = UART_MODE_TX_RX;
  huart2.Init.HwFlowCtl = UART_HWCONTROL_NONE;
  huart2.Init.OverSampling = UART_OVERSAMPLING_16;
  if (HAL_UART_Init(&huart2) != HAL_OK)
  {
    Error_Handler();
  }
  /* USER CODE BEGIN USART2_Init 2 */

  /* USER CODE END USART2_Init 2 */

}

/**
  * @brief USART3 Initialization Function
  * @param None
  * @retval None
  */
static void MX_USART3_UART_Init(void)
{

  /* USER CODE BEGIN USART3_Init 0 */

  /* USER CODE END USART3_Init 0 */

  /* USER CODE BEGIN USART3_Init 1 */

  /* USER CODE END USART3_Init 1 */
  huart3.Instance = USART3;
  huart3.Init.BaudRate = 115200;
  huart3.Init.WordLength = UART_WORDLENGTH_8B;
  huart3.Init.StopBits = UART_STOPBITS_1;
  huart3.Init.Parity = UART_PARITY_NONE;
  huart3.Init.Mode = UART_MODE_TX_RX;
  huart3.Init.HwFlowCtl = UART_HWCONTROL_NONE;
  huart3.Init.OverSampling = UART_OVERSAMPLING_16;
  if (HAL_UART_Init(&huart3) != HAL_OK)
  {
    Error_Handler();
  }
  /* USER CODE BEGIN USART3_Init 2 */

  /* USER CODE END USART3_Init 2 */

}

/**
  * @brief GPIO Initialization Function
  * @param None
  * @retval None
  */
static void MX_GPIO_Init(void)
{
  GPIO_InitTypeDef GPIO_InitStruct = {0};

  /* GPIO Ports Clock Enable */
  __HAL_RCC_GPIOC_CLK_ENABLE();
  __HAL_RCC_GPIOH_CLK_ENABLE();
  __HAL_RCC_GPIOA_CLK_ENABLE();
  __HAL_RCC_GPIOB_CLK_ENABLE();

  /*Configure GPIO pin Output Level */
  HAL_GPIO_WritePin(LD2_GPIO_Port, LD2_Pin, GPIO_PIN_RESET);

  /*Configure GPIO pin : B1_Pin */
  GPIO_InitStruct.Pin = B1_Pin;
  GPIO_InitStruct.Mode = GPIO_MODE_IT_FALLING;
  GPIO_InitStruct.Pull = GPIO_NOPULL;
  HAL_GPIO_Init(B1_GPIO_Port, &GPIO_InitStruct);

  /*Configure GPIO pin : LD2_Pin */
  GPIO_InitStruct.Pin = LD2_Pin;
  GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
  GPIO_InitStruct.Pull = GPIO_NOPULL;
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
  HAL_GPIO_Init(LD2_GPIO_Port, &GPIO_InitStruct);

}

/* USER CODE BEGIN 4 */

/* USER CODE END 4 */

/**
  * @brief  This function is executed in case of error occurrence.
  * @retval None
  */
void Error_Handler(void)
{
  /* USER CODE BEGIN Error_Handler_Debug */
  /* User can add his own implementation to report the HAL error return state */
  __disable_irq();
  while (1)
  {
  }
  /* USER CODE END Error_Handler_Debug */
}

#ifdef  USE_FULL_ASSERT
/**
  * @brief  Reports the name of the source file and the source line number
  *         where the assert_param error has occurred.
  * @param  file: pointer to the source file name
  * @param  line: assert_param error line source number
  * @retval None
  */
void assert_failed(uint8_t *file, uint32_t line)
{
  /* USER CODE BEGIN 6 */
  /* User can add his own implementation to report the file name and line number,
     ex: printf("Wrong parameters value: file %s on line %d\r\n", file, line) */
  /* USER CODE END 6 */
}
#endif /* USE_FULL_ASSERT */

/******************** Implementation of Bootloader Command Handle Functions ********************/

/* Helper function to handle BL_GET_VER command */
void bootloader_handle_getver(uint8_t *bl_rx_buffer) {
	uint8_t bl_version;
	
	//1. Verify the Checksum
	printmsg("BL_DEBUG_MSG: bootloader_handle_getver\n\r");
	
	//Total length of the command packet
	uint32_t command_packet_len = bl_rx_buffer[0] + 1;
	
	//Extract the CRC32 sent by the host
	uint32_t host_crc = *((uint32_t *) (bl_rx_buffer + command_packet_len - 4));
	
	if(!bootloader_verify_crc(&bl_rx_buffer[0], command_packet_len - 4, host_crc)) {
		printmsg("BL_DEBUG_MSG: checksum success!!\n\r");
		//checksum is correct
		bootloader_send_ack(bl_rx_buffer[0], 1);
		bl_version = get_bootloader_version();
		printmsg("BL_DEBUG_MSG: BL_VER: %d %#x\n\r", bl_version, bl_version);
		bootloader_uart_write_data(&bl_version, 1);
	} else {
		printmsg("BL_DEBUG_MSG: checksum fail!!\n\r");
		//checksum is wrong
		bootloader_send_nack();
	}
}

/* Helper function to handle BL_GET_HELP command */
void bootloader_handle_gethelp(uint8_t *bl_rx_buffer) {
	
	printmsg("BL_DEBUG_MSG: bootloader_handle_gethelp\n\r");
	
	//Total length of the command packet
	uint32_t command_packet_len = bl_rx_buffer[0] + 1;
	
	//Extract the CRC32 sent by the Host
	uint32_t host_crc = *((uint32_t *) (bl_rx_buffer + command_packet_len - 4));
	
	if(!bootloader_verify_crc(&bl_rx_buffer[0], command_packet_len - 4, host_crc)) {
		printmsg("BL_DEBUG_MSG: checksum success!!\n\r");
		bootloader_send_ack(bl_rx_buffer[0], sizeof(supported_commands));
		bootloader_uart_write_data(supported_commands, sizeof(supported_commands));
	} else {
		printmsg("BL_DEBUG_MSG: checksum fail!!\n\r");
		bootloader_send_nack();
	}
}

/* Helper function to handle BL_GET_CID command */
void bootloader_handle_getcid(uint8_t *bl_rx_buffer) {
	
	uint16_t bl_cid = 0;
	printmsg("BL_DEBUG_MSG: bootloader_handle_getcid\n\r");
	
	//Total length of the command packet
	uint32_t command_packet_len = bl_rx_buffer[0] + 1;
	
	//Extract the CRC32 sent by the Host
	uint32_t host_crc = *((uint32_t *) (bl_rx_buffer + command_packet_len - 4));
	
	if(!bootloader_verify_crc(&bl_rx_buffer[0], command_packet_len - 4, host_crc)) {
		printmsg("BL_DEBUG_MSG: checksum success!!\n\r");
		bootloader_send_ack(bl_rx_buffer[0], 2);
		bl_cid = get_mcu_chip_id();
		printmsg("BL_DEBUG_MSG: MCU id: #d %#x !!\n\r", bl_cid, bl_cid);
		bootloader_uart_write_data((uint8_t *)&bl_cid, 2);
	} else {
		printmsg("BL_DEBUG_MSG: checksum fail!!\n\r");
		bootloader_send_nack();
	}
}

/* Helper function to handle BL_GET_RDP_STATUS command */
void bootloader_handle_getrdp(uint8_t *bl_rx_buffer) {
	
	uint8_t rdp_level = 0x00;
	printmsg("BL_DEBUG_MSG: bootloader_handle_getrdp\n\r");
	
	//Total length of the command packet
	uint32_t command_packet_len = bl_rx_buffer[0] + 1;
	
	//Extract the CRC32 sent by the Host
	uint32_t host_crc = *((uint32_t *) (bl_rx_buffer + command_packet_len - 4));
	
	if(!bootloader_verify_crc(&bl_rx_buffer[0], command_packet_len - 4, host_crc)) {
		printmsg("BL_DEBUG_MSG: checksum success!!\n\r");
		bootloader_send_ack(bl_rx_buffer[0], 1);
		rdp_level = get_flash_rdp_level();
		printmsg("BL_DEBUG_MSG: RDP Level: #d %#x !!\n\r", rdp_level, rdp_level);
		bootloader_uart_write_data(&rdp_level, 1);
	} else {
		printmsg("BL_DEBUG_MSG: checksum fail!!\n\r");
		bootloader_send_nack();
	}
}

/* Helper function to handle BL_GO_TO_ADDR command */
void bootloader_handle_go_to_addr(uint8_t *bl_rx_buffer) {
	
	uint32_t go_to_address = 0;
	uint8_t addr_valid = ADDR_VALID;
	uint8_t addr_invalid = ADDR_INVALID;
	
	printmsg("BL_DEBUG_MSG: bootloader_handle_go_to_addr\n\r");
	
	//Total length of the command packet
	uint32_t command_packet_len = bl_rx_buffer[0] + 1;
	
	//Extract the CRC32 sent by the Host
	uint32_t host_crc = *((uint32_t *) (bl_rx_buffer + command_packet_len - 4));
	
	if(!bootloader_verify_crc(&bl_rx_buffer[0], command_packet_len - 4, host_crc)) {
		printmsg("BL_DEBUG_MSG: checksum success!!\n\r");
		bootloader_send_ack(bl_rx_buffer[0], 1);
		
		//Extract the Go-To Address
		go_to_address = *((uint32_t *)&bl_rx_buffer[2]);
		printmsg("BL_DEBUG_MSG: Go-To Addr: %#x !!\n\r", go_to_address);
		
		if(verify_address(go_to_address) == ADDR_VALID) {
			//Inform host that address is valid
			bootloader_uart_write_data(&addr_valid,1);

			/* jump to "go-to" address.
			The host must ensure that valid code is present at the destination
			It is not the duty of the bootloader to verify that, so just trust it is correct and jump */

			/* Not doing the below line will result in hardfault exception for ARM cortex M */
			//watch : https://www.youtube.com/watch?v=VX_12SjnNhY
			go_to_address += 1; //Make T-bit = 1 otherwise hardfault exception
			
			void (*lets_jump)(void) = (void *)go_to_address;
			printmsg("BL_DEBUG_MSG: now jumping to go-to address!\n\r");
			lets_jump();
			
		} else {
			printmsg("BL_DEBUG_MSG: go-to address invalid! \n\r");
			//tell host that address is invalid
			bootloader_uart_write_data(&addr_invalid, 1);
		}
		
	} else {
		printmsg("BL_DEBUG_MSG: checksum fail!!\n\r");
		bootloader_send_nack();
	}
}

/* Helper function to handle BL_FLASH_ERASE command */
void bootloader_handle_flash_erase(uint8_t *bl_rx_buffer) {
	
	uint8_t erase_status = 0x00;
	printmsg("BL_DEBUG_MSG: bootloader_handle_flash_erase\n\r");
	
	//Total length of the command packet
	uint32_t command_packet_len = bl_rx_buffer[0] + 1;
	
	//Extract the CRC32 sent by the Host
	uint32_t host_crc = *((uint32_t *) (bl_rx_buffer + command_packet_len - 4));
	
	if(!bootloader_verify_crc(&bl_rx_buffer[0], command_packet_len - 4, host_crc)) {
		printmsg("BL_DEBUG_MSG: checksum success!!\n\r");
		bootloader_send_ack(bl_rx_buffer[0], 1);
		printmsg("BL_DEBUG_MSG: initial_sector: %d no_of_sectors: %d\n\r", bl_rx_buffer[2], bl_rx_buffer[3]);
		
		HAL_GPIO_WritePin(LD2_GPIO_Port, LD2_Pin, 1);
		erase_status = execute_flash_erase(bl_rx_buffer[2], bl_rx_buffer[3]);
		HAL_GPIO_WritePin(LD2_GPIO_Port, LD2_Pin, 0);
		
		printmsg("BL_DEBUG_MSG: flash erase status: %#x\n\r", erase_status);
		
		bootloader_uart_write_data(&erase_status, 1);
		
	} else {
		printmsg("BL_DEBUG_MSG: checksum fail!!\n\r");
		bootloader_send_nack();
	}
}
	
/* Helper function to handle BL_MEM_WRITE command */
void bootloader_handle_mem_write(uint8_t *bl_rx_buffer) {
	
	uint8_t addr_valid = ADDR_VALID;
	uint8_t write_status = 0x00;
	uint8_t chksum = 0, len = 0;
	len = bl_rx_buffer[0];
	uint8_t payload_len = bl_rx_buffer[6];
	
	uint32_t mem_address = *((uint32_t *)(&bl_rx_buffer[2]));
	
	chksum = bl_rx_buffer[len];
	
	printmsg("BL_DEBUG_MSG: bootloader_handle_mem_write\n\r");
	
	//Total length of the command packet
	uint32_t command_packet_len = bl_rx_buffer[0] + 1;
	
	//Extract the CRC32 sent by the Host
	uint32_t host_crc = *((uint32_t *)(bl_rx_buffer + command_packet_len - 4));
	
	if(!bootloader_verify_crc(&bl_rx_buffer[0], command_packet_len - 4, host_crc)) {
		
		printmsg("BL_DEBUG_MSG: checksum success!!\n\r");
		bootloader_send_ack(bl_rx_buffer[0], 1);
		printmsg("BL_DEBUG_MSG: mem write address: %#x\n\r", mem_address);
		
		if(verify_address(mem_address) == ADDR_VALID) {
			printmsg("BL_DEBUG_MSG: valid mem write address\n\r");
			
			//Turn on the LED to indicate that the bootloader is currently writing to memory
			HAL_GPIO_WritePin(LD2_GPIO_Port, LD2_Pin, GPIO_PIN_SET);
			
			//Execute mem write
			write_status = execute_mem_write(&bl_rx_buffer[7], mem_address, payload_len);
			
			//Turn off the LED to indicate memory write is over
			HAL_GPIO_WritePin(LD2_GPIO_Port, LD2_Pin, GPIO_PIN_RESET);
			
			//Inform the Host about the status
			bootloader_uart_write_data(&write_status, 1);
			
		} else {
			printmsg("BL_DEBUG_MSG: invalid mem write address\n\r");
			write_status = ADDR_INVALID;
			//Inform the Host that address is invalid
			bootloader_uart_write_data(&write_status, 1);
		}
		
	} else {
		printmsg("BL_DEBUG_MSG: checksum fail!!\n\r");
		bootloader_send_nack();
	}
}

/* Helper function to handle BL_EN_RW_PROTECT command */
void bootloader_handle_en_rw_protect(uint8_t *bl_rx_buffer) {
	
	uint8_t status = 0x00;
	printmsg("BL_DEBUG_MSG: bootloader_handle_en_rw_protect\n\r");
	
	//Total length of the command packet
	uint32_t command_packet_len = bl_rx_buffer[0] + 1;
	
	//Extract the CRC32 sent by the Host
	uint32_t host_crc = *((uint32_t *)(bl_rx_buffer + command_packet_len - 4));
	
	if(!bootloader_verify_crc(&bl_rx_buffer[0], command_packet_len - 4, host_crc)) {
		printmsg("BL_DEBUG_MSG: checksum success!!\n\r");
		bootloader_send_ack(bl_rx_buffer[0], 1);
		
		status = configure_flash_sector_rw_protection(bl_rx_buffer[2], bl_rx_buffer[3], 0);
		printmsg("BL_DEBUG_MSG: flash erase status: %#x\n\r", status);
		bootloader_uart_write_data(&status, 1);
		
	} else {
    printmsg("BL_DEBUG_MSG: checksum fail!!\n\r");
    bootloader_send_nack();
	}
}

/* Helper function to handle BL_DIS_RW_PROTECT command */
void bootloader_handle_dis_rw_protect(uint8_t *bl_rx_buffer) {
	
	uint8_t status = 0x00;
	printmsg("BL_DEBUG_MSG: bootloader_handle_dis_rw_protect\n\r");
	
	//Total length of the command packet
	uint32_t command_packet_len = bl_rx_buffer[0] + 1;
	
	//Extract the CRC32 sent by the Host
	uint32_t host_crc = *((uint32_t *)(bl_rx_buffer + command_packet_len - 4));
	
	if(!bootloader_verify_crc(&bl_rx_buffer[0], command_packet_len - 4, host_crc)) {
		printmsg("BL_DEBUG_MSG: checksum success!!\n\r");
		bootloader_send_ack(bl_rx_buffer[0], 1);
		
		status = configure_flash_sector_rw_protection(0, 0, 1);
		printmsg("BL_DEBUG_MSG: flash erase status: %#x\n\r", status);
		bootloader_uart_write_data(&status, 1);
		
	} else {
    printmsg("BL_DEBUG_MSG: checksum fail!!\n\r");
    bootloader_send_nack();
	}
}

/* Helper function to handle BL_MEM_READ command */
void bootloader_handle_mem_read(uint8_t *bl_rx_buffer) {
	
}

/* Helper function to handle BL_READ_SECTOR_P_STATUS command */
void bootloader_handle_read_sector_protection_status(uint8_t *bl_rx_buffer) {
	
	uint16_t status;
	printmsg("BL_DEBUG_MSG: bootloader_handle_read_sector_protection_status\n\r");
	
	//Total length of the command packet
	uint32_t command_packet_len = bl_rx_buffer[0] + 1;
	
	//Extract the CRC32 sent by the Host
	uint32_t host_crc = *((uint32_t *)(bl_rx_buffer + command_packet_len - 4));
	
	if(!bootloader_verify_crc(&bl_rx_buffer[0], command_packet_len - 4, host_crc)) {
		printmsg("BL_DEBUG_MSG: checksum success!!\n\r");
		bootloader_send_ack(bl_rx_buffer[0], 2);
		
		status = read_OB_rw_protection_status();
		printmsg("BL_DEBUG_MSG: nWRP status: %#x\n\r", status);
		bootloader_uart_write_data((uint8_t *)&status, 2);
		
	} else {
    printmsg("BL_DEBUG_MSG: checksum fail!!\n\r");
    bootloader_send_nack();
	}
}

/* Helper function to handle BL_OTP_READ command */
void bootloader_handle_read_otp(uint8_t *bl_rx_buffer) {
	
}

/* Sends ACK if CRC matches along with "len to follow" */
void bootloader_send_ack(uint8_t command_code, uint8_t follow_len) {
	
	//Send 2 bytes.. 1st byte is ACK and the 2nd byte is "length to follow"
	uint8_t ack_buf[2];
	ack_buf[0] = BL_ACK;
	ack_buf[1] = follow_len;
	HAL_UART_Transmit(C_UART, ack_buf, 2, HAL_MAX_DELAY);
}

void bootloader_send_nack(void) {
	uint8_t nack = BL_NACK;
	HAL_UART_Transmit(C_UART, &nack, 1, HAL_MAX_DELAY);
}

/* Verifies the CRC of the given buffer in pData */
uint8_t bootloader_verify_crc(uint8_t *pData, uint32_t len, uint32_t crc_host) {
	
	uint32_t uwCRCValue = 0xFF;
	
	for(uint32_t i = 0; i < len; i++) {
		uint32_t i_data = pData[i];
		uwCRCValue = HAL_CRC_Accumulate(&hcrc, &i_data, 1);
	}
	
	/* Reset CRC Calculation Unit */
	__HAL_CRC_DR_RESET(&hcrc);
	
	if(uwCRCValue == crc_host) {
		return VERIFY_CRC_SUCCESS;
	}
	
	return VERIFY_CRC_FAIL;
}

/* Writes Data into C_UART */
void bootloader_uart_write_data(uint8_t *pBuffer, uint32_t len) {
	
	HAL_UART_Transmit(C_UART, pBuffer, len, HAL_MAX_DELAY);
}

uint8_t get_bootloader_version(void) {
	
	return (uint8_t)BL_VERSION;
}

//Read the Chip or Device ID
uint16_t get_mcu_chip_id(void) {
	/*
	 * The STM32F446xx MCUs integrate an MCU ID code. This ID identifies the ST MCU partnumber
	 * and the die revision. It is part of the DBG_MCU component and is mapped on the
	 * external PPB bus (see Section 33.16 on page 1304). This code is accessible using the
	 * JTAG debug pCat.2ort (4 to 5 pins) or the SW debug port (two pins) or by the user software.
	 * It is even accessible while the MCU is under system reset. */
	uint16_t cid;
	cid = (uint16_t)(DBGMCU->IDCODE) & 0x0FFF;
	return cid;
}

uint8_t get_flash_rdp_level(void) {
	
	uint8_t rdp_status = 0;
	
#if 0
	//HAL / ST library APIs
	FLASH_OBProgramInitTypeDef ob_handle;
	HAL_FLASHEx_OBGetConfig(&ob_handle);
	rdp_status = (uint8_t)ob_handle.RDPLevel;
	
#else
	volatile uint32_t *pOB_addr = (uint32_t*) 0x1FFFC000;
	rdp_status = (uint8_t)(*pOB_addr >> 8);
	
#endif
	
	return rdp_status;
}

uint8_t verify_address(uint32_t go_to_address) {
	/* Valid addresses:
	 * System Memory (ROM), SRAM1, SRAM2, Backup SRAM, 
	 * Peripheral Memory (possible but not allowing that feature), 
	 * External Memory */
	
	if((go_to_address >= SRAM1_BASE) && (go_to_address <= SRAM1_END)) {
		return ADDR_VALID;
		
	} else if((go_to_address >= SRAM2_BASE) && (go_to_address <= SRAM2_END)) {
		return ADDR_VALID;
		
	} else if((go_to_address >= FLASH_BASE) && (go_to_address <= FLASH_END)) {
		return ADDR_VALID;
		
	} else if((go_to_address >= BKPSRAM_BASE) && (go_to_address <= BKPSRAM_END)) {
		return ADDR_VALID;
		
	} else {
		return ADDR_INVALID;
	}	
}

uint8_t execute_flash_erase(uint8_t sector_number, uint8_t number_of_sectors) {
	//There are 8 sectors in STM32F446RE MCU (Sector[0:7])
	//number_of_sectors must be in the range of 0 to 7
	//if sector_number = 0xFF, that means mass erase
	
	FLASH_EraseInitTypeDef flashErase_handle; 
	uint32_t sectorError;
	HAL_StatusTypeDef status;
	
	if(number_of_sectors > 8)
		return INVALID_SECTOR;
	
	if((sector_number == 0xFF) || (sector_number <= 7)) {
		
		if(sector_number == (uint8_t) 0xFF) {
			flashErase_handle.TypeErase = FLASH_TYPEERASE_MASSERASE;
			
		} else {
			//Calculate how many sectors need to be erased
			uint8_t remaining_sector = 8 - sector_number;
			
			if(number_of_sectors > remaining_sector) {
				number_of_sectors = remaining_sector;
			}
			
			flashErase_handle.TypeErase = FLASH_TYPEERASE_SECTORS;
			flashErase_handle.Sector = sector_number; //The initial sector
			flashErase_handle.NbSectors = number_of_sectors;
		}
		
		flashErase_handle.Banks = FLASH_BANK_1;
		
		//Gain access to modify the FLASH registers
		HAL_FLASH_Unlock();
		flashErase_handle.VoltageRange = FLASH_VOLTAGE_RANGE_3;
		status = (uint8_t) HAL_FLASHEx_Erase(&flashErase_handle, &sectorError);
		HAL_FLASH_Lock();
		
		return status;
	}
	
	return INVALID_SECTOR;
}

/* Writes the contents of pBuffer to "mem_address" byte by byte */
//Note1 : Currently this function supports writing to Flash only.
//Note2 : This function doesn't check whether "mem_address" is a valid address of the Flash memory
uint8_t execute_mem_write(uint8_t *pBuffer, uint32_t mem_address, uint32_t len) {
	
	uint8_t status = HAL_OK;
	
	//Unlock flash module to gain control of registers
	HAL_FLASH_Unlock();
	
	for(uint32_t i = 0; i < len; i++) {
		//Program the flash byte by byte
		status = HAL_FLASH_Program(FLASH_TYPEPROGRAM_BYTE, mem_address + i, pBuffer[i]);
	}
	
	HAL_FLASH_Lock();
	
	return status;
}

/*
Modifying user option bytes
To modify the user option value, follow the sequence below:
1. Check that no Flash memory operation is ongoing by checking the BSY bit in the
FLASH_SR register
2. Write the desired option value in the FLASH_OPTCR register.
3. Set the option start bit (OPTSTRT) in the FLASH_OPTCR register
4. Wait for the BSY bit to be cleared.
*/
uint8_t configure_flash_sector_rw_protection(uint8_t sector_details, uint8_t protection_mode, uint8_t disable) {
	//First configure the protection mode
	//protection_mode = 1, means write protect of the user flash sectors
	//protection_mode = 2, means read/write protect of the user flash sectors
	//According to RM of stm32f446xx TABLE 9, We have to modify the address 0x1FFF C008 bit 15(SPRMOD)
	
	//Flash option control register (OPTCR)
	volatile uint32_t *pOPTCR = (uint32_t *) 0x40023C14;
	
	if(disable) {
	//DISABLE all r/w protection on sectors
		//Option byte configuration unlock
		HAL_FLASH_OB_Unlock();
		
		//Wait until no active operations on flash
		while(__HAL_FLASH_GET_FLAG(FLASH_FLAG_BSY) != RESET);
		
		//Clear the 31st bit (default state) - Refer to: Flash Option Control Register (FLASH_OPTCR) in RM
		*pOPTCR &= ~(1 << 31);
		
		//Clear the protection: Make all bits belonging to sectors as 1
		*pOPTCR |= (0xFF << 16);
		
		//Set the Option Start Bit (OPTSTRT) in the FLASH_OPTCR register
		*pOPTCR |= (1 << 1);
		
		//Wait until no active operations on flash
		while(__HAL_FLASH_GET_FLAG(FLASH_FLAG_BSY) != RESET);
		
		HAL_FLASH_OB_Lock();
		
		return 0;
	}
	
	if(protection_mode == (uint8_t) 1) {
	//Put Write Protection on the sectors encoded in sector_details argument
		//Option Byte Configuration unlock
		HAL_FLASH_OB_Unlock();
	
		//Wait until no active operations on flash
		while(__HAL_FLASH_GET_FLAG(FLASH_FLAG_BSY) != RESET);
		
		//Set Write Protection for the sectors
		//Clear the 31st bit (default state) - Refer to: Flash Option Control Register (FLASH_OPTCR) in RM
		*pOPTCR &= ~(1 << 31);
		
		//Set WP on sectors
		*pOPTCR &= ~(sector_details << 16);
		
		//Set the Option Start Bit (OPTSTRT) in the FLASH_OPTCR register
		*pOPTCR |= (1 << 1);
		
		//Wait until no active operations on flash
		while(__HAL_FLASH_GET_FLAG(FLASH_FLAG_BSY) != RESET);	
		
		HAL_FLASH_OB_Lock();
		
	} else if(protection_mode == (uint8_t) 2) {
	//Put Read and Write Protections on the sectors encoded in sector_details argument
		//Option Byte Configuration unlock
		HAL_FLASH_OB_Unlock();
		
		//Wait until no active operations on flash
		while(__HAL_FLASH_GET_FLAG(FLASH_FLAG_BSY) != RESET);
		
		//Setting Read and Write Protections for the sectors
		//Set the 31st bit - Refer to: Flash Option Control Register (FLASH_OPTCR) in RM
		*pOPTCR |= (1 << 31);
		
		//Set R&W Protections on sectors
		*pOPTCR &= ~(0xFF << 16);
		*pOPTCR |= (sector_details << 16);
		
		//Set the Option Start Bit (OPTSTRT) in the FLASH_OPTCR register
		*pOPTCR |= (1 << 1);
		
		//Wait until no active operations on flash
		while(__HAL_FLASH_GET_FLAG(FLASH_FLAG_BSY) != RESET);	
		
		HAL_FLASH_OB_Lock();
	}
	
	return 0;
}

uint16_t read_OB_rw_protection_status(void) {
	//This structure is defined in ST Flash driver to hold the OB(Option Byte) contents
	FLASH_OBProgramInitTypeDef OBInit;
	
	//Unlock the OB(Option Byte) memory access
	HAL_FLASH_OB_Unlock();
	//Get the OB configuration details
	HAL_FLASHEx_OBGetConfig(&OBInit);
	//Lock the OB memory access
	HAL_FLASH_OB_Lock();
	
	//Only interested in R/W protection status of the sectors
	return (uint16_t)OBInit.WRPSector;
}

/************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/



/****************************************************************************************************/
									User_app_STM32F446xx
/****************************************************************************************************/
/**
  ******************************************************************************
  * @file           : main.c
  * @brief          : Main program body
  ******************************************************************************
  * @attention
  *
  * <h2><center>&copy; Copyright (c) 2021 STMicroelectronics.
  * All rights reserved.</center></h2>
  *
  * This software component is licensed by ST under BSD 3-Clause license,
  * the "License"; You may not use this file except in compliance with the
  * License. You may obtain a copy of the License at:
  *                        opensource.org/licenses/BSD-3-Clause
  *
  ******************************************************************************
  */
/* USER CODE END Header */
/* Includes ------------------------------------------------------------------*/
#include "main.h"

/* Private includes ----------------------------------------------------------*/
/* USER CODE BEGIN Includes */

/* USER CODE END Includes */

/* Private typedef -----------------------------------------------------------*/
/* USER CODE BEGIN PTD */

/* USER CODE END PTD */

/* Private define ------------------------------------------------------------*/
/* USER CODE BEGIN PD */
/* USER CODE END PD */

/* Private macro -------------------------------------------------------------*/
/* USER CODE BEGIN PM */

/* USER CODE END PM */

/* Private variables ---------------------------------------------------------*/
UART_HandleTypeDef huart2;

/* USER CODE BEGIN PV */

/* USER CODE END PV */

/* Private function prototypes -----------------------------------------------*/
void SystemClock_Config(void);
static void MX_GPIO_Init(void);
static void MX_USART2_UART_Init(void);
/* USER CODE BEGIN PFP */

/* USER CODE END PFP */

/* Private user code ---------------------------------------------------------*/
/* USER CODE BEGIN 0 */

/* USER CODE END 0 */

char userdata[] = "Hello from user application\r\n";

/**
  * @brief  The application entry point.
  * @retval int
  */
int main(void)
{
  /* USER CODE BEGIN 1 */

  /* USER CODE END 1 */

  /* MCU Configuration--------------------------------------------------------*/

  /* Reset of all peripherals, Initializes the Flash interface and the Systick. */
  HAL_Init();

  /* USER CODE BEGIN Init */

  /* USER CODE END Init */

  /* Configure the system clock */
  SystemClock_Config();

  /* USER CODE BEGIN SysInit */

  /* USER CODE END SysInit */

  /* Initialize all configured peripherals */
  MX_GPIO_Init();
  MX_USART2_UART_Init();
  /* USER CODE BEGIN 2 */

  /* USER CODE END 2 */

  /* Infinite loop */
  /* USER CODE BEGIN WHILE */
  while (1)
  {
    /* USER CODE END WHILE */
		HAL_UART_Transmit(&huart2, (uint8_t*)userdata, sizeof(userdata), HAL_MAX_DELAY);
		uint32_t current_tick = HAL_GetTick();
		HAL_GPIO_TogglePin(LD2_GPIO_Port, LD2_Pin);
		while(HAL_GetTick() <= 1000 + current_tick);
    /* USER CODE BEGIN 3 */
  }
  /* USER CODE END 3 */
}

/**
  * @brief System Clock Configuration
  * @retval None
  */
void SystemClock_Config(void)
{
  RCC_OscInitTypeDef RCC_OscInitStruct = {0};
  RCC_ClkInitTypeDef RCC_ClkInitStruct = {0};

  /** Configure the main internal regulator output voltage
  */
  __HAL_RCC_PWR_CLK_ENABLE();
  __HAL_PWR_VOLTAGESCALING_CONFIG(PWR_REGULATOR_VOLTAGE_SCALE3);
  /** Initializes the RCC Oscillators according to the specified parameters
  * in the RCC_OscInitTypeDef structure.
  */
  RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSI;
  RCC_OscInitStruct.HSIState = RCC_HSI_ON;
  RCC_OscInitStruct.HSICalibrationValue = RCC_HSICALIBRATION_DEFAULT;
  RCC_OscInitStruct.PLL.PLLState = RCC_PLL_NONE;
  if (HAL_RCC_OscConfig(&RCC_OscInitStruct) != HAL_OK)
  {
    Error_Handler();
  }
  /** Initializes the CPU, AHB and APB buses clocks
  */
  RCC_ClkInitStruct.ClockType = RCC_CLOCKTYPE_HCLK|RCC_CLOCKTYPE_SYSCLK
                              |RCC_CLOCKTYPE_PCLK1|RCC_CLOCKTYPE_PCLK2;
  RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_HSI;
  RCC_ClkInitStruct.AHBCLKDivider = RCC_SYSCLK_DIV1;
  RCC_ClkInitStruct.APB1CLKDivider = RCC_HCLK_DIV2;
  RCC_ClkInitStruct.APB2CLKDivider = RCC_HCLK_DIV1;

  if (HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_0) != HAL_OK)
  {
    Error_Handler();
  }
}

/**
  * @brief USART2 Initialization Function
  * @param None
  * @retval None
  */
static void MX_USART2_UART_Init(void)
{

  /* USER CODE BEGIN USART2_Init 0 */

  /* USER CODE END USART2_Init 0 */

  /* USER CODE BEGIN USART2_Init 1 */

  /* USER CODE END USART2_Init 1 */
  huart2.Instance = USART2;
  huart2.Init.BaudRate = 115200;
  huart2.Init.WordLength = UART_WORDLENGTH_8B;
  huart2.Init.StopBits = UART_STOPBITS_1;
  huart2.Init.Parity = UART_PARITY_NONE;
  huart2.Init.Mode = UART_MODE_TX_RX;
  huart2.Init.HwFlowCtl = UART_HWCONTROL_NONE;
  huart2.Init.OverSampling = UART_OVERSAMPLING_16;
  if (HAL_UART_Init(&huart2) != HAL_OK)
  {
    Error_Handler();
  }
  /* USER CODE BEGIN USART2_Init 2 */

  /* USER CODE END USART2_Init 2 */

}

/**
  * @brief GPIO Initialization Function
  * @param None
  * @retval None
  */
static void MX_GPIO_Init(void)
{
  GPIO_InitTypeDef GPIO_InitStruct = {0};

  /* GPIO Ports Clock Enable */
  __HAL_RCC_GPIOC_CLK_ENABLE();
  __HAL_RCC_GPIOH_CLK_ENABLE();
  __HAL_RCC_GPIOA_CLK_ENABLE();
  __HAL_RCC_GPIOB_CLK_ENABLE();

  /*Configure GPIO pin Output Level */
  HAL_GPIO_WritePin(LD2_GPIO_Port, LD2_Pin, GPIO_PIN_RESET);

  /*Configure GPIO pin : B1_Pin */
  GPIO_InitStruct.Pin = B1_Pin;
  GPIO_InitStruct.Mode = GPIO_MODE_IT_FALLING;
  GPIO_InitStruct.Pull = GPIO_NOPULL;
  HAL_GPIO_Init(B1_GPIO_Port, &GPIO_InitStruct);

  /*Configure GPIO pin : LD2_Pin */
  GPIO_InitStruct.Pin = LD2_Pin;
  GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
  GPIO_InitStruct.Pull = GPIO_NOPULL;
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
  HAL_GPIO_Init(LD2_GPIO_Port, &GPIO_InitStruct);

  /* EXTI interrupt init*/
  HAL_NVIC_SetPriority(EXTI15_10_IRQn, 0, 0);
  HAL_NVIC_EnableIRQ(EXTI15_10_IRQn);

}

/* USER CODE BEGIN 4 */

/* USER CODE END 4 */

/**
  * @brief  This function is executed in case of error occurrence.
  * @retval None
  */
void Error_Handler(void)
{
  /* USER CODE BEGIN Error_Handler_Debug */
  /* User can add his own implementation to report the HAL error return state */
  __disable_irq();
  while (1)
  {
  }
  /* USER CODE END Error_Handler_Debug */
}




/****************************************************************************************************/
								HOST - C - STM32_Programmer_V1
/****************************************************************************************************/

Files in Directory:
BlCommands.c
BlReplyProcessing.c
fileops.c
LinuxSerialPort.c
main.c
OSxSerialPort.c 
utilities.c
WindowsSerialPort.c

LinuxSerialPort.h
main.h
OSxSerialPort.h
WindowsSerialPort.h

////////////////////////////// BlCommands.c ///////////////////////////////

/* This file implements logic to decode the user input , prepare and send the bootloader command packet
 * over the serial port. This file is common across win/linux/mac
 */

#include "main.h"

//Decode the Bootloader command selection by the user
void decode_menu_command_code(uint32_t command_code)
{

    unsigned char data_buf[255];
    uint32_t crc32=0; int ret_value=0;

    switch(command_code)
    {
    case 0:
        printf("\n  Exiting...!");
        exit(0);

    case 1:
        printf("\n   Command == > BL_GET_VER");

        data_buf[0] = COMMAND_BL_GET_VER_LEN-1;
        data_buf[1] = COMMAND_BL_GET_VER;
        crc32       = get_crc(data_buf,COMMAND_BL_GET_VER_LEN-4);
        data_buf[2] = word_to_byte(crc32,1,1);
        data_buf[3] = word_to_byte(crc32,2,1);
        data_buf[4] = word_to_byte(crc32,3,1);
        data_buf[5] = word_to_byte(crc32,4,1);

        Write_to_serial_port(&data_buf[0],1);
        Write_to_serial_port(&data_buf[1],COMMAND_BL_GET_VER_LEN-1);

        ret_value = read_bootloader_reply(data_buf[1]);

        break;

    case 2:
        printf("\n   Command == > BL_GET_HLP");

        data_buf[0] = COMMAND_BL_GET_HELP_LEN-1;
        data_buf[1] = COMMAND_BL_GET_HELP;
        crc32       = get_crc(data_buf,COMMAND_BL_GET_HELP_LEN-4);
        data_buf[2] = word_to_byte(crc32,1,1);
        data_buf[3] = word_to_byte(crc32,2,1);
        data_buf[4] = word_to_byte(crc32,3,1);
        data_buf[5] = word_to_byte(crc32,4,1);

        Write_to_serial_port(&data_buf[0],1);
        Write_to_serial_port(&data_buf[1],COMMAND_BL_GET_HELP_LEN-1);

        ret_value = read_bootloader_reply(data_buf[1]);

        break;

    case 3:
        printf("\n   Command == > BL_GET_CID");

        data_buf[0] = COMMAND_BL_GET_CID_LEN-1;
        data_buf[1] = COMMAND_BL_GET_CID;
        crc32       = get_crc(data_buf,COMMAND_BL_GET_CID_LEN-4);
        data_buf[2] = word_to_byte(crc32,1,1);
        data_buf[3] = word_to_byte(crc32,2,1);
        data_buf[4] = word_to_byte(crc32,3,1);
        data_buf[5] = word_to_byte(crc32,4,1);

        Write_to_serial_port(&data_buf[0],1);
        Write_to_serial_port(&data_buf[1],COMMAND_BL_GET_CID_LEN-1);

        ret_value = read_bootloader_reply(data_buf[1]);

        break;

    case 4:
        printf("\n   Command == > BL_GET_RDP_STATUS");

        data_buf[0] = COMMAND_BL_GET_RDP_STATUS_LEN-1;
        data_buf[1] = COMMAND_BL_GET_RDP_STATUS;
        crc32       = get_crc(data_buf,COMMAND_BL_GET_RDP_STATUS_LEN-4);
        data_buf[2] = word_to_byte(crc32,1,1);
        data_buf[3] = word_to_byte(crc32,2,1);
        data_buf[4] = word_to_byte(crc32,3,1);
        data_buf[5] = word_to_byte(crc32,4,1);

        Write_to_serial_port(&data_buf[0],1);
        Write_to_serial_port(&data_buf[1],COMMAND_BL_GET_RDP_STATUS_LEN-1);

        ret_value = read_bootloader_reply(data_buf[1]);

        break;

    case 5:
        printf("\n   Command == > BL_GO_TO_ADDR");
        printf("\n\n   Enter Address here :");
        uint32_t go_address;
        scanf(" %x",&go_address);

        data_buf[0] = COMMAND_BL_GO_TO_ADDR_LEN-1;
        data_buf[1] = COMMAND_BL_GO_TO_ADDR;
#if 0
        data_buf[2] = word_to_byte(RESET_HANDLER_ADDR_OF_APP,1,1);
        data_buf[3] = word_to_byte(RESET_HANDLER_ADDR_OF_APP,2,1);
        data_buf[4] = word_to_byte(RESET_HANDLER_ADDR_OF_APP,3,1);
        data_buf[5] = word_to_byte(RESET_HANDLER_ADDR_OF_APP,4,1);
#endif
        data_buf[2] = word_to_byte(go_address,1,1);
        data_buf[3] = word_to_byte(go_address,2,1);
        data_buf[4] = word_to_byte(go_address,3,1);
        data_buf[5] = word_to_byte(go_address,4,1);
        crc32       = get_crc(data_buf,COMMAND_BL_GO_TO_ADDR_LEN-4);
        data_buf[6] = word_to_byte(crc32,1,1);
        data_buf[7] = word_to_byte(crc32,2,1);
        data_buf[8] = word_to_byte(crc32,3,1);
        data_buf[9] = word_to_byte(crc32,4,1);

        Write_to_serial_port(&data_buf[0],1);
        Write_to_serial_port(&data_buf[1],COMMAND_BL_GO_TO_ADDR_LEN-1);

        ret_value = read_bootloader_reply(data_buf[1]);

        break;

    case 6:
        printf("\n   This command is not supported\n");
        break;

    case 7:
        printf("\n   Command == > BL_FLASH_ERASE");

        data_buf[0] = COMMAND_BL_FLASH_ERASE_LEN-1;
        data_buf[1] = COMMAND_BL_FLASH_ERASE;
        uint32_t sector_num,nsec;

        printf("\n  Enter sector number(0-7 or 0xFF) here :");
        scanf(" %x",&sector_num);
        if(sector_num != 0xff)
        {
            printf("\n  Enter number of sectors to erase(max 8) here :");
            scanf(" %d",&nsec);

        }


        data_buf[2]= sector_num;
        data_buf[3]= nsec;
       // printf(" sector num : %d %d \n",sector_num,nsec);

        crc32       = get_crc(data_buf,COMMAND_BL_FLASH_ERASE_LEN-4);
        data_buf[4] = word_to_byte(crc32,1,1);
        data_buf[5] = word_to_byte(crc32,2,1);
        data_buf[6] = word_to_byte(crc32,3,1);
        data_buf[7] = word_to_byte(crc32,4,1);

        Write_to_serial_port(&data_buf[0],1);
        Write_to_serial_port(&data_buf[1],COMMAND_BL_FLASH_ERASE_LEN-1);

        ret_value = read_bootloader_reply(data_buf[1]);

        break;

    case 8:
        printf("\n   Command == > BL_MEM_WRITE");
        uint32_t bytes_remaining=0;
        uint32_t t_len_of_file=0;
        uint32_t bytes_so_far_sent = 0,len_to_read=0;
        uint32_t base_mem_address=0;

        data_buf[1] = COMMAND_BL_MEM_WRITE;

        //First get the total number of bytes in the .bin file.
        t_len_of_file =calc_file_len();

        //keep opening the file
        open_the_file();

        bytes_remaining = t_len_of_file - bytes_so_far_sent;

#if 0
        //Here you should  get it from user input . but
        //for testing purpose just hard coded.
        base_mem_address = USE_APP_FLASH_BASE_ADDR;
#endif
        printf("\n\n   Enter the memory write address here :");
        scanf(" %x",&base_mem_address);

        while(bytes_remaining)
        {

            if(bytes_remaining >= 128)
            {
                len_to_read = 128;
            }else
            {
                len_to_read = bytes_remaining;
            }

            //get the bytes in to buffer by reading file
            read_the_file(&data_buf[7],len_to_read);

            printf("\n   base mem address = %#.8x\n",base_mem_address);

            //populate base mem address
            data_buf[2] = word_to_byte(base_mem_address,1,1);
            data_buf[3] = word_to_byte(base_mem_address,2,1);
            data_buf[4] = word_to_byte(base_mem_address,3,1);
            data_buf[5] = word_to_byte(base_mem_address,4,1);

            data_buf[6] = len_to_read;

            /* 1 byte len + 1 byte command code + 4 byte mem base address
             * 1 byte payload len + len_to_read is amount of bytes read from file + 4 byte CRC
             */
            uint32_t mem_write_cmd_total_len = COMMAND_BL_MEM_WRITE_LEN(len_to_read);

            //first field is "len_to_follow"
            data_buf[0] =mem_write_cmd_total_len-1;

            crc32       = get_crc(&data_buf[0],mem_write_cmd_total_len-4);
            data_buf[7+len_to_read] = word_to_byte(crc32,1,1);
            data_buf[8+len_to_read] = word_to_byte(crc32,2,1);
            data_buf[9+len_to_read] = word_to_byte(crc32,3,1);
            data_buf[10+len_to_read] = word_to_byte(crc32,4,1);

            //update base mem address for the next loop
            base_mem_address+=len_to_read;

            Write_to_serial_port(&data_buf[0],1);
            Write_to_serial_port(&data_buf[1],mem_write_cmd_total_len-1);

            bytes_so_far_sent+=len_to_read;
            bytes_remaining = t_len_of_file - bytes_so_far_sent;

            printf("\n\n    bytes_so_far_sent:%d -- bytes_remaining:%d\n",bytes_so_far_sent,bytes_remaining);

            ret_value = read_bootloader_reply(data_buf[1]);

         }
        break;

    case 9:
        printf("\n   Command == > BL_EN_R_W_PROTECT");
        printf("\n\n   How many sectors do you want to protect ?: ");
        uint32_t total_sector,mode;
        char user_input;
        uint32_t sector_details = 0x00;
        uint8_t sector_numbers[8];
        scanf(" %d",&total_sector);
        for(uint32_t i=0 ; i < total_sector ; i++)
        {
            printf("\n   Enter sector number[%d]:",i+1);
            scanf(" %d",&sector_numbers[i]);
            sector_details = sector_details | (1 << sector_numbers[i]);
        }

       // printf("\n   Sector info : 0x%x",sector_details);

        printf("\n   Mode:Flash sectors Write Protection: 1");
        printf("\n   Mode:Flash sectors Read/Write Protection: 2");
        printf("\n   Enter Sector Protection Mode(1 or 2 ):");
        scanf(" %d",&mode);
        if(mode != 2 && mode != 1)
        {
            printf("\n   Invalid option : Command Dropped");
            return;
        }
        if(mode == 2)
        {
#if 0
          printf("\n   Mass Erase will be performed if you later want to change the Protection mode");
          printf("\n   Are you sure (y/n) ?:");
          scanf(" %c",&user_input);
          if( (user_input != 'Y' ) && (user_input != 'y') )
          {
            printf("\n   Command Dropped");
            return ;

          }
#endif
           printf("\n   This feature is currently not supported !");
           return ;

        }

        data_buf[0] = COMMAND_BL_EN_R_W_PROTECT_LEN-1;
        data_buf[1] = COMMAND_BL_EN_R_W_PROTECT;
        data_buf[2] = sector_details;
        data_buf[3] = mode;
        crc32       = get_crc(data_buf,COMMAND_BL_EN_R_W_PROTECT_LEN-4);
        data_buf[4] = word_to_byte(crc32,1,1);
        data_buf[5] = word_to_byte(crc32,2,1);
        data_buf[6] = word_to_byte(crc32,3,1);
        data_buf[7] = word_to_byte(crc32,4,1);

        Write_to_serial_port(&data_buf[0],1);
        Write_to_serial_port(&data_buf[1],COMMAND_BL_EN_R_W_PROTECT_LEN-1);

        ret_value = read_bootloader_reply(data_buf[1]);
        break;
    case 10:
        printf("\n   Command == > COMMAND_BL_MEM_READ");
        printf("\n   This command is not supported");
        break;
    case 11:
        printf("\n   Command == > COMMAND_BL_READ_SECTOR_P_STATUS");

        data_buf[0] = COMMAND_BL_READ_SECTOR_P_STATUS_LEN-1;
        data_buf[1] = COMMAND_BL_READ_SECTOR_P_STATUS;

        crc32       = get_crc(data_buf,COMMAND_BL_READ_SECTOR_P_STATUS_LEN-4);
        data_buf[2] = word_to_byte(crc32,1,1);
        data_buf[3] = word_to_byte(crc32,2,1);
        data_buf[4] = word_to_byte(crc32,3,1);
        data_buf[5] = word_to_byte(crc32,4,1);

        Write_to_serial_port(&data_buf[0],1);
        Write_to_serial_port(&data_buf[1],COMMAND_BL_READ_SECTOR_P_STATUS_LEN-1);

        ret_value = read_bootloader_reply(data_buf[1]);

        break;
    case 12:

        printf("\n   Command == > COMMAND_OTP_READ");
        printf("\n   This command is not supported");

        break;
    case 13:
        printf("\n   Command == > COMMAND_BL_DIS_R_W_PROTECT");
        //printf("\n   This command is not supported");
        data_buf[0] = COMMAND_BL_DIS_R_W_PROTECT_LEN-1;
        data_buf[1] = COMMAND_BL_DIS_R_W_PROTECT;
        crc32       = get_crc(data_buf,COMMAND_BL_DIS_R_W_PROTECT_LEN-4);
        data_buf[2] = word_to_byte(crc32,1,1);
        data_buf[3] = word_to_byte(crc32,2,1);
        data_buf[4] = word_to_byte(crc32,3,1);
        data_buf[5] = word_to_byte(crc32,4,1);

        Write_to_serial_port(&data_buf[0],1);
        Write_to_serial_port(&data_buf[1],COMMAND_BL_DIS_R_W_PROTECT_LEN-1);

        ret_value = read_bootloader_reply(data_buf[1]);
        break;

    case 14:
        printf("\n   Command == > COMMAND_BL_MY_NEW_COMMAND ");
        data_buf[0] = COMMAND_BL_MY_NEW_COMMAND_LEN-1;
        data_buf[1] = COMMAND_BL_MY_NEW_COMMAND;
        crc32       = get_crc(data_buf,COMMAND_BL_MY_NEW_COMMAND_LEN-4);
        data_buf[2] = word_to_byte(crc32,1,1);
        data_buf[3] = word_to_byte(crc32,2,1);
        data_buf[4] = word_to_byte(crc32,3,1);
        data_buf[5] = word_to_byte(crc32,4,1);

        Write_to_serial_port(&data_buf[0],1);
        Write_to_serial_port(&data_buf[1],COMMAND_BL_MY_NEW_COMMAND_LEN-1);

        ret_value = read_bootloader_reply(data_buf[1]);
        break;

    default:
        {
            printf("\n\n  Please input valid command code\n");
            return;
        }

    }

        if(ret_value == -2)
        {
            printf("\n\n   TimeOut : No response from the bootloader");
            printf("\n   Reset the board and Try Again !\n");
            return;
        }
}

////////////////////////////// BlReplyProcessing.c ///////////////////////////////

/* This file implements the logic to read and process the replies from the Bootloader .
 * This file is common across win/linux/mac
 */

#include "main.h"



//Reads and processes the reply sent from the MCU bootloader
int read_bootloader_reply(uint8_t command_code)
{
    uint8_t ack[2]={0}; //MCU sends ack + len field
    uint32_t len_to_follow=0;
    int ret = -2;

    //The MCU bootloader always sends ack/nack first . read that !!
    read_serial_port(ack,2);
    if(ack[0] == 0xA5)
    {
        //CRC of last command was good .. received ACK and "len to follow"
        len_to_follow=ack[1];
        printf("\n\n   CRC : SUCCESS Len : %d\n",len_to_follow);

        switch(0x50 | command_code)
        {
        case COMMAND_BL_GET_VER:
             process_COMMAND_BL_GET_VER(len_to_follow);
            break;
        case COMMAND_BL_GET_HELP:
            process_COMMAND_BL_GET_HELP(len_to_follow);
            break;
        case COMMAND_BL_GET_CID:
            process_COMMAND_BL_GET_CID(len_to_follow);
            break;
        case COMMAND_BL_GET_RDP_STATUS:
            process_COMMAND_BL_GET_RDP_STATUS(len_to_follow);
            break;
        case COMMAND_BL_GO_TO_ADDR:
            process_COMMAND_BL_GO_TO_ADDR(len_to_follow);
            break;
        case COMMAND_BL_FLASH_ERASE:
            process_COMMAND_BL_FLASH_ERASE(len_to_follow);
            break;
        case COMMAND_BL_MEM_WRITE:
            process_COMMAND_BL_MEM_WRITE(len_to_follow);
            break;
        case COMMAND_BL_READ_SECTOR_P_STATUS:
            process_COMMAND_BL_READ_SECTOR_STATUS(len_to_follow);
            break;
        case COMMAND_BL_EN_R_W_PROTECT:
            process_COMMAND_BL_EN_R_W_PROTECT(len_to_follow);
            break;
        case COMMAND_BL_DIS_R_W_PROTECT:
            process_COMMAND_BL_DIS_R_W_PROTECT(len_to_follow);
            break;
        case COMMAND_BL_MY_NEW_COMMAND:
            process_COMMAND_BL_MY_NEW_COMMAND(len_to_follow);
        default:
            printf("\n  Invalid command code\n");

        }

          ret = 0;
    }
    else if( ack[0] == 0x7F)
    {
        //CRC of last command was bad .. received NACK
        printf("\n   CRC: FAIL \n");
        ret= -1;
    }

    return ret;
}

void process_COMMAND_BL_MY_NEW_COMMAND(uint32_t len)
{


}

void process_COMMAND_BL_GET_VER(uint32_t len)
{
    uint8_t ver;
    read_serial_port(&ver,len);
    printf("\n   Bootloader Ver. : 0x%x\n",ver);
}


void process_COMMAND_BL_GET_HELP(uint32_t len)
{
    uint8_t reply[15];
    read_serial_port(reply,len);
    printf("\n   Supported Commands :");
    for(uint32_t i =0 ; i < len ; i++)
    printf("0x%x  ",reply[i]);
    printf("\n");
}


void process_COMMAND_BL_GET_CID(uint32_t len)
{
    uint8_t cid[2];
    uint16_t ci=0;
    read_serial_port(cid,len);
    ci = (uint16_t)(cid[1] << 8 )+ cid[0];
    printf("\n   Chip Id. : 0x%x\n",ci);
}



void process_COMMAND_BL_GET_RDP_STATUS(uint32_t len)
{
    uint8_t rdp=0;
    read_serial_port(&rdp,len);
    printf("\n   RDP Status : 0x%X\n",rdp);
}


void process_COMMAND_BL_GO_TO_ADDR(uint32_t len)
{
    uint8_t addr_status=0;
    read_serial_port(&addr_status,len);
    printf("\n   Address Status : 0x%x\n",addr_status);
}


void process_COMMAND_BL_FLASH_ERASE(uint32_t len)
{
    uint8_t erase_status=0;
    read_serial_port(&erase_status,len);
    if(erase_status == Flash_HAL_OK)
    {
        printf("\n  Erase Status: Success  Code: Flash_HAL_OK\n");
    }
    else if(erase_status == Flash_HAL_ERROR)
    {
        printf("\n  Erase Status: Fail  Code: Flash_HAL_ERROR\n");

    }
    else if(erase_status == Flash_HAL_BUSY)
    {
        printf("\n  Erase Status: Fail  Code: Flash_HAL_BUSY\n");
    }
    else if(erase_status == Flash_HAL_TIMEOUT)
    {
        printf("\n  Erase Status: Fail  Code: Flash_HAL_TIMEOUT\n");
    }
     else if(erase_status == Flash_HAL_INV_ADDR)
    {
        printf("\n  Erase Status: Fail  Code: Flash_HAL_INV_SECTOR\n");
    }
    else
    {
        printf("\n  Erase Status: Fail  Code: UNKNOWN_ERROR_CODE\n");
    }
   // printf("     Erase Status : 0x%x\n",erase_status);
}

void process_COMMAND_BL_FLASH_MASS_ERASE(uint32_t len_to_follow)
{


}


void process_COMMAND_BL_MEM_WRITE(uint32_t len)
{
    uint8_t write_status=0;
    read_serial_port(&write_status,len);
    if(write_status == Flash_HAL_OK)
    {
        printf("\n   Write_status: Flash_HAL_OK\n");
    }
    else if(write_status == Flash_HAL_ERROR)
    {
        printf("\n   Write_status: Flash_HAL_ERROR\n");
    }
    else if(write_status == Flash_HAL_BUSY)
    {
        printf("\n   Write_status: Flash_HAL_BUSY\n");
    }
    else if(write_status == Flash_HAL_TIMEOUT)
    {
        printf("\n   Write_status: Flash_HAL_TIMEOUT\n");
    }
     else if(write_status == Flash_HAL_INV_ADDR)
    {
        printf("\n   Write_status: Flash_HAL_INV_ADDR\n");
    }
    else
    {
        printf("\n   Write_status: UNKNOWN_ERROR\n");
    }
   // printf("     Erase Status : 0x%x\n",erase_status);
}



char *mode[3]= { "Write Protection", "Read/Write Protection","No protection"};
char *protection_type(t_sector_status *pStatus, uint32_t n)
{

    if(pStatus->flash_sector_status & (1 << 15))
    { //PCROP is active
       // printf("\n  Flash protection mode : Read/Write Protection(PCROP)");

        if(pStatus->flash_sector_status & (1 << n))
        {
             return mode[1];
        }else
        {
            return mode[2];
        }

    }else
    {
       // printf("\n  Flash protection mode : Write Protection\n");
        if(pStatus->flash_sector_status & (1 << n))
        {
             return mode[2];
        }else
        {
            return mode[0];
        }
    }

}

void process_COMMAND_BL_READ_SECTOR_STATUS(uint32_t len)
{
    uint32_t i;
  //  uint16_t sectors_status=0;
    t_sector_status s_status;

    read_serial_port((uint8_t*)&s_status.flash_sector_status,len);
   // s_status.flash_sector_status = (uint16_t)(status[1] << 8 | status[0] );
    printf("\n   Sector Status : 0x%.4X\n",s_status.flash_sector_status);
    printf("\n  ====================================");
    printf("\n  Sector                  Protection");
    printf("\n  ====================================");
    if(s_status.flash_sector_status & (1 << 15))
    { //PCROP is active
        printf("\n  Flash protection mode : Read/Write Protection(PCROP)\n");
    }
    else
    {
        printf("\n  Flash protection mode : Write Protection\n");
    }

    for(i=0;i<8;i++)
    printf("\n  Sector%d                 %s",i,protection_type(&s_status,i));

    printf("\n");
}

void process_COMMAND_BL_EN_R_W_PROTECT(uint8_t len)
{
     uint8_t status=0;
     read_serial_port(&status,len);
     if(status)
     {
        printf("\n   FAIL\n");
     }else
     {
        printf("\n   SUCCESS\n");
     }
}

process_COMMAND_BL_DIS_R_W_PROTECT(uint8_t len)
{
     uint8_t status=0;
     read_serial_port(&status,len);
     if(status)
     {
         printf("\n   FAIL \n");
     }else
     {
        printf("\n   SUCCESS\n");
     }

}

int check_flash_status(void)
{
    uint8_t ack[2]={0};
    //uint32_t i =0;
    int ret = -1;

    uint8_t ch = 0;

    //The MCU bootloader always sends ack/nack first . read that !!
    read_serial_port(ack,2);
    if(ack[0] == 0xA5)
    {
        //CRC of last command was good .. received ACK and "len to follow"
        printf("ACK received : %d\n",ack[1]);
        //ReadFile(hComm, &ch, 1, &read, NULL);
        read_serial_port(&ch,1);
        printf("flash status : %d\n",ch);
        ret = 0;
    }
    else if ( ack[0] == 0x7F)
    {
        //CRC of last command was bad .. received NACK
        printf("\nNACK received \n");
        ret= -1;
    }

    return ret;
}

////////////////////////////// fileops.c ///////////////////////////////

/* This file implements file operations functions . Used to open , close and read the binary file .
 * This file is common across win/linux/mac
 */

#include "main.h"

FILE *file=NULL; //File pointer for our file related I/O

//This is the name of the .bin file stored in the below path .
#define USER_APP "C:\\Users\\kiran\\Documents\\bin\\user_app.bin"



//This function opens the file, calculates and returns total length in bytes
uint32_t calc_file_len(void)
{
    FILE *file;
    uint32_t fileLen;

    //OPen the file in binary format to read.
    file = fopen(USER_APP, "rb");

    if(! file){
        // fprintf(stderr, "Unable to open file %s", "user_app.bin");
        perror("\n\n   bin file not found");
        exit(0);
    }

    //Get file length
	fseek(file, 0, SEEK_END);
	fileLen=ftell(file);
	fseek(file, 0, SEEK_SET);

    fclose(file);

    return fileLen;

}

//This function opens the file , global file handle is used to store the file pointer
void open_the_file(void)
 {
    file = fopen(USER_APP, "rb");

    if(! file){
        // fprintf(stderr, "Unable to open file %s", "user_app.bin");
        perror("\n   bin file not found");
        exit(0);
    }

 }

 //This function reads the file for a given "len" bytes
uint32_t read_the_file(uint8_t *buffer, uint32_t len)
{
    uint32_t ret=0;

    //Read file contents into buffer
	ret=fread(buffer, 1, len, file);

	//return how much is really read
    return ret;

}

//close the global file handle
void close_the_file(void)
{
    fclose(file);
}


////////////////////////////// LinuxSerialPort.c ///////////////////////////////
#include "main.h"

#ifdef LINUX_HOST

/* If you are here, then you may be trying to run this STM32_Programmer Application on Linux Host.
   Note1 : This file should implement the functions mentioned in the "LinuxSerialPort.h"
   Note2 : Take a reference from the source file "WindowsSerialPort.c
 */

 #include "LinuxSerialPort.h"

/* Code Begin */



/* Code End */

 #endif

////////////////////////////// main.c ///////////////////////////////
#include "main.h"

int main()
{
     /*----------------------------- Ask Menu implementation----------------------------------------*/
    printf("\n\n +==========================================+");
    printf("\n |           STM32F4 BootLoader v1           |");
    printf("\n +==========================================+\n");


    Serial_Port_Configuration();

    while(1)
    {
#if 1
        printf("\n\n +==========================================+");
        printf("\n |                   Menu                   |");
        printf("\n +==========================================+\n");
#endif
        printf("\n\n   Which BL command do you want to send ??\n");
        printf("\n   BL_GET_VER                     --> 1");
        printf("\n   BL_GET_HLP                     --> 2");
        printf("\n   BL_GET_CID                     --> 3");
        printf("\n   BL_GET_RDP_STATUS              --> 4");
        printf("\n   BL_GO_TO_ADDR                  --> 5");
        printf("\n   BL_FLASH_MASS_ERASE            --> 6");
        printf("\n   BL_FLASH_ERASE                 --> 7");
        printf("\n   BL_MEM_WRITE                   --> 8");
        printf("\n   BL_EN_R_W_PROTECT              --> 9");
        printf("\n   BL_MEM_READ                    --> 10");
        printf("\n   BL_READ_SECTOR_P_STATUS        --> 11");
        printf("\n   BL_OTP_READ                    --> 12");
        printf("\n   BL_DIS_R_W_PROTECT             --> 13");
        printf("\n   BL_MY_NEW_COMMAND              --> 14");
        printf("\n   MENU_EXIT                      --> 0");

        printf("\n\n   Type the command code here :");

        uint32_t command_code;
        scanf(" %d",&command_code);

        decode_menu_command_code(command_code);

#if 0
        printf("\n\n   Do you want to continue(y/n) ?:");
        uint8_t proceed = 0;
        scanf(" %c",&proceed);
        proceed -= 'y';
        if ( proceed)
        {
            printf("\n  ****** Thank you ! Exiting ******\n");
            break;
        }
#endif
        printf("\n\n   Press any key to continue  :");
        uint8_t ch = getch();
        purge_serial_port();
   }
}

////////////////////////////// OSxSerialPort.c ///////////////////////////////
#include "main.h"

#ifdef OSX_HOST

/* If you are here, then you may be trying to run this STM32_Programmer Application on OSX Host.
   Note1 : This file should implement the functions mentioned in the "OSxSerialPort.h"
   Note2 : Take a reference from the source file "WindowsSerialPort.c
 */

 #include "OSxSerialPort.h"

/* Code Begin */



/* Code End */

 #endif
 
////////////////////////////// utilities.c ///////////////////////////////

/* This file implements some of the utility functions like conversions, CRC calculations , etc
 * This file is common across win/linux/mac
 */

#include "main.h"

//Converts uint32t_t value to series of bytes.
//if "lowerfirst" is 1 , then LSB is returned first (not used)
uint8_t word_to_byte(uint32_t addr, uint8_t index, uint8_t lowerfirst)
{
      uint8_t value = (addr >> ( 8 * ( index -1)) & 0x000000FF );
      return value;
}


//This function computes the 4 byte CRC(CRC32) using polynomial method
//Please refer these links for more details
//https://community.st.com/thread/18626
//http://www.st.com/content/ccc/resource/technical/document/application_note/39/89/da/89/9e/d7/49/b1/DM00068118.pdf/files/DM00068118.pdf/jcr:content/translations/en.DM00068118.pdf
//http://www.hackersdelight.org/hdcodetxt/crc.c.txt
//http://www.zlib.net/crc_v3.txt
uint32_t get_crc(uint8_t *buff, uint32_t len)
{
    uint32_t i;

    uint32_t Crc = 0XFFFFFFFF;

    for(uint32_t n = 0 ; n < len ; n++ )
    {
        uint32_t data = buff[n];
        Crc = Crc ^ data;
        for(i=0; i<32; i++)
        {

        if (Crc & 0x80000000)
            Crc = (Crc << 1) ^ 0x04C11DB7; // Polynomial used in STM32
        else
            Crc = (Crc << 1);
        }

    }

  return(Crc);
}

////////////////////////////// WindowsSerialPort.c ///////////////////////////////
#include "main.h"

#ifdef WINDOWS_HOST

HANDLE hComm;                          // Handle to the Serial port

void Serial_Port_Configuration(void)
{
    char   ComPortName[] = "\\\\.\\COM3"; // Name of the Serial port(May Change) to be opened,
    BOOL   Status;

/*----------------------------------- Opening the Serial Port --------------------------------------------*/
    hComm = CreateFile( ComPortName,                       // Name of the Port to be Opened
                        GENERIC_READ | GENERIC_WRITE,      // Read/Write Access
                        0,                                 // No Sharing, ports cant be shared
                        NULL,                              // No Security
                        OPEN_EXISTING,                     // Open existing port only
                        0,                                 // Non Overlapped I/O
                        NULL);                             // Null for Comm Devices

    if (hComm == INVALID_HANDLE_VALUE)
    {
         printf("\n   Error! - Port %s can't be opened", ComPortName);
         printf("\n   Check board connection and Port Number\n");
         exit(-1);
    }

    else
        printf("\n   Port %s Opened\n ", ComPortName);

/*------------------------------- Setting the Parameters for the SerialPort ------------------------------*/

    DCB dcbSerialParams = { 0 };                        // Initializing DCB structure
    dcbSerialParams.DCBlength = sizeof(dcbSerialParams);

    Status = GetCommState(hComm, &dcbSerialParams);     //retreives  the current settings

    if (Status == FALSE)
        printf("\n   Error! in GetCommState()");

    dcbSerialParams.BaudRate = 115200;      // Setting BaudRate = 9600
    dcbSerialParams.ByteSize = 8; // Setting ByteSize = 8
    dcbSerialParams.fBinary = 1;
    dcbSerialParams.StopBits = ONESTOPBIT;    // Setting StopBits = 1
    dcbSerialParams.Parity   = NOPARITY;      // Setting Parity = None

    Status = SetCommState(hComm, &dcbSerialParams);  //Configuring the port according to settings in DCB

    if (Status == FALSE)
    {
        printf("\n   Error! in Setting DCB Structure");
    }
    else
    {
        printf("\n   Setting DCB Structure Successfull\n");
        printf("\n       Baudrate = %ld", dcbSerialParams.BaudRate);
        printf("\n       ByteSize = %d", dcbSerialParams.ByteSize);
        printf("\n       StopBits = %d", dcbSerialParams.StopBits);
        printf("\n       Parity   = %d", dcbSerialParams.Parity);
    }
/*------------------------------------ Setting Timeouts --------------------------------------------------*/
#if 1
    COMMTIMEOUTS timeouts = { 0 };

    timeouts.ReadIntervalTimeout         = 300;
    timeouts.ReadTotalTimeoutConstant    = 300;
    timeouts.ReadTotalTimeoutMultiplier  = 300;
    timeouts.WriteTotalTimeoutConstant   = 50;
    timeouts.WriteTotalTimeoutMultiplier = 10;

    if (SetCommTimeouts(hComm, &timeouts) == FALSE)
        printf("\n   Error! in Setting Time Outs");
    else
        printf("\n\n   Setting Serial Port Timeouts Successfull");

    Status = SetCommMask(hComm, EV_RXCHAR); //Configure Windows to Monitor the serial device for Character Reception

    if (Status == FALSE)
        printf("\n\n   Error! in Setting CommMask");
    else
        printf("\n\n   Setting CommMask successfull");
#endif



}

/* This function reads from the serial port and returns count of  bytes read */
uint32_t read_serial_port(uint8_t *pBuffer, uint32_t len)
{
    uint32_t no_of_bytes_read;

    ReadFile(hComm, pBuffer, len, &no_of_bytes_read, NULL);

    return no_of_bytes_read;

}

//closes the serial port
void Close_serial_port(void)
{
    CloseHandle(hComm);//Closing the Serial Port
}

//explore : https://msdn.microsoft.com/en-us/library/windows/desktop/aa363428(v=vs.85).aspx
void purge_serial_port(void)
{
     PurgeComm(hComm,PURGE_RXCLEAR|PURGE_TXCLEAR);

}

//This fun is used to Send data over the serial port of "len" bytes
void Write_to_serial_port(uint8_t *data_buf, uint32_t len)
{
    DWORD  dNoOfBytesWritten = 0;          // No of bytes written to the port
    BOOL   Status;

    Status = WriteFile( hComm,               // Handle to the Serialport
                        data_buf,            // Data to be written to the port
                        len,   // No of bytes to write into the port
                        &dNoOfBytesWritten,  // No of bytes written to the port
                        NULL);

    if (Status == TRUE)
    {
        printf("\n   Sending Command:\n");
        for(uint32_t i = 0 ; i < len ; i++)
        {
            printf("   0x%2.2x ",data_buf[i]);
            if( i % 8 == 7)
            {
                printf("\n");
            }
        }
    }
    else
        printf("\n  Error %ld in Writing to Serial Port",GetLastError());
}

#endif // WINDOWS_HOST

////////////////////////////// LinuxSerialPort.h ///////////////////////////////
#ifndef LINUX_SERIAL_H_INCLUDED
#define LINUX_SERIAL_H_INCLUDED

//Serial port related prototypes
void Serial_Port_Configuration(void);
uint32_t read_serial_port(uint8_t *pBuffer, uint32_t len);
void Close_serial_port(void);
void purge_serial_port(void);
void Write_to_serial_port(uint8_t *data_buf, uint32_t len);


#endif // LINUX_SERIAL_H_INCLUDED

////////////////////////////// main.h ///////////////////////////////
#ifndef MAIN_H_INCLUDED
#define MAIN_H_INCLUDED

#include <Windows.h>
#include <stdio.h>
#include <string.h>
#include <stdint.h>

//enable one of the below macro according to your HOST
#define WINDOWS_HOST
//#define LINUX_HOST
//s#define OSX_HOST

#ifdef WINDOWS_HOST
    #include "WindowsSerialPort.h"
#endif

#ifdef LINUX_HOST
    #include "LinuxSerialPort.h"
#endif

#ifdef OSX_HOST
    #include "OSxSerialPort.h"
#endif

//Bl commands prototypes
void decode_menu_command_code(uint32_t command_code);

//BL Reply Process prototypes
void process_COMMAND_BL_MY_NEW_COMMAND(uint32_t len);
void process_COMMAND_BL_EN_R_W_PROTECT(uint8_t len);
void process_COMMAND_BL_DIS_R_W_PROTECT(uint8_t len);
void process_COMMAND_BL_READ_SECTOR_STATUS(uint32_t len);
void process_COMMAND_BL_MEM_WRITE(uint32_t len);
void process_COMMAND_BL_FLASH_ERASE(uint32_t len);
void process_COMMAND_BL_FLASH_MASS_ERASE(uint32_t len_to_follow);
void process_COMMAND_BL_GO_TO_ADDR(uint32_t len);
void process_COMMAND_BL_GET_RDP_STATUS(uint32_t len);
void process_COMMAND_BL_GET_CID(uint32_t len);
void process_COMMAND_BL_GET_HELP(uint32_t len);
void process_COMMAND_BL_GET_VER(uint32_t len);
int read_bootloader_reply(uint8_t command_code);
int check_flash_status(void);

//utilities Prototypes
uint32_t get_crc(uint8_t *buff, uint32_t len);
uint8_t word_to_byte(uint32_t addr, uint8_t index, uint8_t lowerfirst);

//file ops
void close_the_file(void);
uint32_t read_the_file(uint8_t *buffer, uint32_t len);
void open_the_file(void);
uint32_t calc_file_len(void);

//BL Commands
#define COMMAND_BL_GET_VER                  0x51
#define COMMAND_BL_GET_HELP                 0x52
#define COMMAND_BL_GET_CID                  0x53
#define COMMAND_BL_GET_RDP_STATUS           0x54
#define COMMAND_BL_GO_TO_ADDR               0x55
#define COMMAND_BL_FLASH_ERASE              0x56
#define COMMAND_BL_MEM_WRITE                0x57
#define COMMAND_BL_EN_R_W_PROTECT           0x58
#define COMMAND_BL_MEM_READ                 0x59
#define COMMAND_BL_READ_SECTOR_P_STATUS     0x5A
#define COMMAND_BL_OTP_READ                 0x5B
#define COMMAND_BL_DIS_R_W_PROTECT          0x5C
#define COMMAND_BL_MY_NEW_COMMAND           0x5D

//len details of the command
#define COMMAND_BL_GET_VER_LEN              6
#define COMMAND_BL_GET_HELP_LEN             6
#define COMMAND_BL_GET_CID_LEN              6
#define COMMAND_BL_GET_RDP_STATUS_LEN       6
#define COMMAND_BL_GO_TO_ADDR_LEN           10
#define COMMAND_BL_FLASH_ERASE_LEN          8
#define COMMAND_BL_MEM_WRITE_LEN(x)         (7+x+4)
#define COMMAND_BL_EN_R_W_PROTECT_LEN       8
#define COMMAND_BL_READ_SECTOR_P_STATUS_LEN   6
#define COMMAND_BL_DIS_R_W_PROTECT_LEN       6
#define COMMAND_BL_MY_NEW_COMMAND_LEN        8


//These addresses are used for GO_TO_ADDR for testing purpose.
#define GO_TO_ADDR1 0x20001234
#define GO_TO_ADDR2 0x40804434
#define GO_TO_ADDR3 0x08001234
#define GO_TO_ADDR4 0x12801234
#define GO_TO_ADDR5 0X08008248

//This is the flash sector 2 base address where we have stored the user application
#define USE_APP_FLASH_BASE_ADDR 0X08008000

#define RESET_HANDLER_ADDR_OF_APP 0x080081D8

//MCU HAL driver operation status .. currently not used.
 /**
  * @brief  HAL Status structures definition
  */
typedef enum
{
  HAL_OK       = 0x00U,
  HAL_ERROR    = 0x01U,
  HAL_BUSY     = 0x02U,
  HAL_TIMEOUT  = 0x03U
} HAL_StatusTypeDef;

//MCU HAL Flash driver operation status .. currently not used
 /**
  * @brief  Flash HAL Status structures definition
  */
typedef enum
{
  Flash_HAL_OK       = 0x00U,
  Flash_HAL_ERROR    = 0x01U,
  Flash_HAL_BUSY     = 0x02U,
  Flash_HAL_TIMEOUT  = 0x03U,
  Flash_HAL_INV_ADDR = 0x04U
} HAL_FlashStatusTypeDef;


typedef union
{
    uint16_t flash_sector_status;
    struct
    {
        uint16_t sector0:2;
        uint16_t sector1:2;
        uint16_t sector2:2;
        uint16_t sector3:2;
        uint16_t sector4:2;
        uint16_t sector5:2;
        uint16_t sector6:2;
        uint16_t sector7:2;

    }sectors;

}t_sector_status;


#endif // MAIN_H_INCLUDED

////////////////////////////// OSxSerialPort.h ///////////////////////////////
#ifndef OSX_SERIAL_H_INCLUDED
#define OSX_SERIAL_H_INCLUDED

//Serial port related prototypes
void Serial_Port_Configuration(void);
uint32_t read_serial_port(uint8_t *pBuffer, uint32_t len);
void Close_serial_port(void);
void purge_serial_port(void);
void Write_to_serial_port(uint8_t *data_buf, uint32_t len);


#endif // OSX_SERIAL_H_INCLUDED

////////////////////////////// WindowsSerialPort.h ///////////////////////////////
#ifndef WINDOWS_SERIAL_H_INCLUDED
#define WINDOWS_SERIAL_H_INCLUDED

//Serial port related prototypes
void Serial_Port_Configuration(void);
uint32_t read_serial_port(uint8_t *pBuffer, uint32_t len);
void Close_serial_port(void);
void purge_serial_port(void);
void Write_to_serial_port(uint8_t *data_buf, uint32_t len);


#endif // WINDOWS_SERIAL_H_INCLUDED


/****************************************************************************************************/
								HOST - Python - STM32_Programmer_V1
/****************************************************************************************************/
import serial
import struct
import os
import sys
import glob

Flash_HAL_OK                                        = 0x00
Flash_HAL_ERROR                                     = 0x01
Flash_HAL_BUSY                                      = 0x02
Flash_HAL_TIMEOUT                                   = 0x03
Flash_HAL_INV_ADDR                                  = 0x04

#BL Commands
COMMAND_BL_GET_VER                                  = 0x51
COMMAND_BL_GET_HELP                                 = 0x52
COMMAND_BL_GET_CID                                  =0x53
COMMAND_BL_GET_RDP_STATUS                           =0x54
COMMAND_BL_GO_TO_ADDR                               =0x55
COMMAND_BL_FLASH_ERASE                              =0x56
COMMAND_BL_MEM_WRITE                                =0x57
COMMAND_BL_EN_R_W_PROTECT                           =0x58
COMMAND_BL_MEM_READ                                 =0x59
COMMAND_BL_READ_SECTOR_P_STATUS                     =0x5A
COMMAND_BL_OTP_READ                                 =0x5B
COMMAND_BL_DIS_R_W_PROTECT                          =0x5C
COMMAND_BL_MY_NEW_COMMAND                           =0x5D


#len details of the command
COMMAND_BL_GET_VER_LEN                              =6
COMMAND_BL_GET_HELP_LEN                             =6
COMMAND_BL_GET_CID_LEN                              =6
COMMAND_BL_GET_RDP_STATUS_LEN                       =6
COMMAND_BL_GO_TO_ADDR_LEN                           =10
COMMAND_BL_FLASH_ERASE_LEN                          =8
COMMAND_BL_MEM_WRITE_LEN                            = 11
COMMAND_BL_EN_R_W_PROTECT_LEN                       =8
COMMAND_BL_READ_SECTOR_P_STATUS_LEN                 =6
COMMAND_BL_DIS_R_W_PROTECT_LEN                      =6
COMMAND_BL_MY_NEW_COMMAND_LEN                       =8


verbose_mode = 1
mem_write_active =0

#----------------------------- file ops----------------------------------------

def calc_file_len():
    size = os.path.getsize("user_app.bin")
    return size

def open_the_file():
    global bin_file
    bin_file = open('user_app.bin','rb')
    #read = bin_file.read()
    #global file_contents = bytearray(read)

def read_the_file():
    pass

def close_the_file():
    bin_file.close()




#----------------------------- utilities----------------------------------------

def word_to_byte(addr, index , lowerfirst):
    value = (addr >> ( 8 * ( index -1)) & 0x000000FF )
    return value

def get_crc(buff, length):
    Crc = 0xFFFFFFFF
    #print(length)
    for data in buff[0:length]:
        Crc = Crc ^ data
        for i in range(32):
            if(Crc & 0x80000000):
                Crc = (Crc << 1) ^ 0x04C11DB7
            else:
                Crc = (Crc << 1)
    return Crc

#----------------------------- Serial Port ----------------------------------------
def serial_ports():
    """ Lists serial port names
        :raises EnvironmentError:
            On unsupported or unknown platforms
        :returns:
            A list of the serial ports available on the system
    """
    if sys.platform.startswith('win'):
        ports = ['COM%s' % (i + 1) for i in range(256)]
    elif sys.platform.startswith('linux') or sys.platform.startswith('cygwin'):
        # this excludes your current terminal "/dev/tty"
        ports = glob.glob('/dev/tty[A-Za-z]*')
    elif sys.platform.startswith('darwin'):
        ports = glob.glob('/dev/tty.*')
    else:
        raise EnvironmentError('Unsupported platform')

    result = []
    for port in ports:
        try:
            s = serial.Serial(port)
            s.close()
            result.append(port)
        except (OSError, serial.SerialException):
            pass
    return result

def Serial_Port_Configuration(port):
    global ser
    try:
        ser = serial.Serial(port,115200,timeout=2)
    except:
        print("\n   Oops! That was not a valid port")
        
        port = serial_ports()
        if(not port):
            print("\n   No ports Detected")
        else:
            print("\n   Here are some available ports on your PC. Try Again!")
            print("\n   ",port)
        return -1
    if ser.is_open:
        print("\n   Port Open Success")
    else:
        print("\n   Port Open Failed")
    return 0

              
def read_serial_port(length):
    read_value = ser.read(length)
    return read_value

def Close_serial_port():
    pass
def purge_serial_port():
    ser.reset_input_buffer()
    
def Write_to_serial_port(value, *length):
        data = struct.pack('>B', value)
        if (verbose_mode):
            value = bytearray(data)
            #print("   "+hex(value[0]), end='')
            print("   "+"0x{:02x}".format(value[0]),end=' ')
        if(mem_write_active and (not verbose_mode)):
                print("#",end=' ')
        ser.write(data)


        
#----------------------------- command processing----------------------------------------

def process_COMMAND_BL_MY_NEW_COMMAND(length):
    pass

def process_COMMAND_BL_GET_VER(length):
    ver=read_serial_port(1)
    value = bytearray(ver)
    print("\n   Bootloader Ver. : ",hex(value[0]))

def process_COMMAND_BL_GET_HELP(length):
    #print("reading:", length)
    value = read_serial_port(length) 
    reply = bytearray(value)
    print("\n   Supported Commands :",end=' ')
    for x in reply:
        print(hex(x),end=' ')
    print()

def process_COMMAND_BL_GET_CID(length):
    value = read_serial_port(length)
    ci = (value[1] << 8 )+ value[0]
    print("\n   Chip Id. : ",hex(ci))

def process_COMMAND_BL_GET_RDP_STATUS(length):
    value = read_serial_port(length)
    rdp = bytearray(value)
    print("\n   RDP Status : ",hex(rdp[0]))

def process_COMMAND_BL_GO_TO_ADDR(length):
    addr_status=0
    value = read_serial_port(length)
    addr_status = bytearray(value)
    print("\n   Address Status : ",hex(addr_status[0]))

def process_COMMAND_BL_FLASH_ERASE(length):
    erase_status=0
    value = read_serial_port(length)
    if len(value):
        erase_status = bytearray(value)
        if(erase_status[0] == Flash_HAL_OK):
            print("\n   Erase Status: Success  Code: FLASH_HAL_OK")
        elif(erase_status[0] == Flash_HAL_ERROR):
            print("\n   Erase Status: Fail  Code: FLASH_HAL_ERROR")
        elif(erase_status[0] == Flash_HAL_BUSY):
            print("\n   Erase Status: Fail  Code: FLASH_HAL_BUSY")
        elif(erase_status[0] == Flash_HAL_TIMEOUT):
            print("\n   Erase Status: Fail  Code: FLASH_HAL_TIMEOUT")
        elif(erase_status[0] == Flash_HAL_INV_ADDR):
            print("\n   Erase Status: Fail  Code: FLASH_HAL_INV_SECTOR")
        else:
            print("\n   Erase Status: Fail  Code: UNKNOWN_ERROR_CODE")
    else:
        print("Timeout: Bootloader is not responding")

def process_COMMAND_BL_MEM_WRITE(length):
    write_status=0
    value = read_serial_port(length)
    write_status = bytearray(value)
    if(write_status[0] == Flash_HAL_OK):
        print("\n   Write_status: FLASH_HAL_OK")
    elif(write_status[0] == Flash_HAL_ERROR):
        print("\n   Write_status: FLASH_HAL_ERROR")
    elif(write_status[0] == Flash_HAL_BUSY):
        print("\n   Write_status: FLASH_HAL_BUSY")
    elif(write_status[0] == Flash_HAL_TIMEOUT):
        print("\n   Write_status: FLASH_HAL_TIMEOUT")
    elif(write_status[0] == Flash_HAL_INV_ADDR):
        print("\n   Write_status: FLASH_HAL_INV_ADDR")
    else:
        print("\n   Write_status: UNKNOWN_ERROR")
    print("\n")
    

def process_COMMAND_BL_FLASH_MASS_ERASE(length):
    pass



protection_mode= [ "Write Protection", "Read/Write Protection","No protection" ]
def protection_type(status,n):
    if( status & (1 << 15) ):
        #PCROP is active
        if(status & (1 << n) ):
            return protection_mode[1]
        else:
            return protection_mode[2]
    else:
        if(status & (1 << n)):
            return protection_mode[2]
        else:
            return protection_mode[0]
            
        
        
        
def process_COMMAND_BL_READ_SECTOR_STATUS(length):
    s_status=0

    value = read_serial_port(length)
    s_status = bytearray(value)
    #s_status.flash_sector_status = (uint16_t)(status[1] << 8 | status[0] )
    print("\n   Sector Status : ",s_status[0])
    print("\n  ====================================")
    print("\n  Sector                               \tProtection") 
    print("\n  ====================================")
    if(s_status[0] & (1 << 15)):
        #PCROP is active
        print("\n  Flash protection mode : Read/Write Protection(PCROP)\n")
    else:
        print("\n  Flash protection mode :   \tWrite Protection\n")

    for x in range(8):
        print("\n   Sector{0}                               {1}".format(x,protection_type(s_status[0],x) ) )
        


def process_COMMAND_BL_DIS_R_W_PROTECT(length):
    status=0
    value = read_serial_port(length)
    status = bytearray(value)
    if(status[0]):
        print("\n   FAIL")
    else:
        print("\n   SUCCESS")

def process_COMMAND_BL_EN_R_W_PROTECT(length):
    status=0
    value = read_serial_port(length)
    status = bytearray(value)
    if(status[0]):
        print("\n   FAIL")
    else:
        print("\n   SUCCESS")




def decode_menu_command_code(command):
    ret_value = 0
    data_buf = []
    for i in range(255):
        data_buf.append(0)
    
    if(command  == 0 ):
        print("\n   Exiting...!")
        raise SystemExit
    elif(command == 1):
        print("\n   Command == > BL_GET_VER")
        COMMAND_BL_GET_VER_LEN              = 6
        data_buf[0] = COMMAND_BL_GET_VER_LEN-1 
        data_buf[1] = COMMAND_BL_GET_VER 
        crc32       = get_crc(data_buf,COMMAND_BL_GET_VER_LEN-4)
        crc32 = crc32 & 0xffffffff
        data_buf[2] = word_to_byte(crc32,1,1) 
        data_buf[3] = word_to_byte(crc32,2,1) 
        data_buf[4] = word_to_byte(crc32,3,1) 
        data_buf[5] = word_to_byte(crc32,4,1) 

        
        Write_to_serial_port(data_buf[0],1)
        for i in data_buf[1:COMMAND_BL_GET_VER_LEN]:
            Write_to_serial_port(i,COMMAND_BL_GET_VER_LEN-1)
        

        ret_value = read_bootloader_reply(data_buf[1])
        
        

    elif(command == 2):
        print("\n   Command == > BL_GET_HELP")
        COMMAND_BL_GET_HELP_LEN             =6
        data_buf[0] = COMMAND_BL_GET_HELP_LEN-1 
        data_buf[1] = COMMAND_BL_GET_HELP 
        crc32       = get_crc(data_buf,COMMAND_BL_GET_HELP_LEN-4)
        crc32 = crc32 & 0xffffffff
        data_buf[2] = word_to_byte(crc32,1,1) 
        data_buf[3] = word_to_byte(crc32,2,1) 
        data_buf[4] = word_to_byte(crc32,3,1) 
        data_buf[5] = word_to_byte(crc32,4,1) 

        
        Write_to_serial_port(data_buf[0],1)
        for i in data_buf[1:COMMAND_BL_GET_HELP_LEN]:
            Write_to_serial_port(i,COMMAND_BL_GET_HELP_LEN-1)
        

        ret_value = read_bootloader_reply(data_buf[1])
    elif(command == 3):
        print("\n   Command == > BL_GET_CID")
        COMMAND_BL_GET_CID_LEN             =6
        data_buf[0] = COMMAND_BL_GET_CID_LEN-1 
        data_buf[1] = COMMAND_BL_GET_CID 
        crc32       = get_crc(data_buf,COMMAND_BL_GET_CID_LEN-4)
        crc32 = crc32 & 0xffffffff
        data_buf[2] = word_to_byte(crc32,1,1) 
        data_buf[3] = word_to_byte(crc32,2,1) 
        data_buf[4] = word_to_byte(crc32,3,1) 
        data_buf[5] = word_to_byte(crc32,4,1) 

        
        Write_to_serial_port(data_buf[0],1)
        for i in data_buf[1:COMMAND_BL_GET_CID_LEN]:
            Write_to_serial_port(i,COMMAND_BL_GET_CID_LEN-1)
        

        ret_value = read_bootloader_reply(data_buf[1])

    elif(command == 4):
        print("\n   Command == > BL_GET_RDP_STATUS")
        data_buf[0] = COMMAND_BL_GET_RDP_STATUS_LEN-1
        data_buf[1] = COMMAND_BL_GET_RDP_STATUS
        crc32       = get_crc(data_buf,COMMAND_BL_GET_RDP_STATUS_LEN-4)
        crc32 = crc32 & 0xffffffff
        data_buf[2] = word_to_byte(crc32,1,1)
        data_buf[3] = word_to_byte(crc32,2,1)
        data_buf[4] = word_to_byte(crc32,3,1)
        data_buf[5] = word_to_byte(crc32,4,1)
        
        Write_to_serial_port(data_buf[0],1)
        
        for i in data_buf[1:COMMAND_BL_GET_RDP_STATUS_LEN]:
            Write_to_serial_port(i,COMMAND_BL_GET_RDP_STATUS_LEN-1)
        
        ret_value = read_bootloader_reply(data_buf[1])
    elif(command == 5):
        print("\n   Command == > BL_GO_TO_ADDR")
        go_address  = input("\n   Please enter 4 bytes go address in hex:")
        go_address = int(go_address, 16)
        data_buf[0] = COMMAND_BL_GO_TO_ADDR_LEN-1 
        data_buf[1] = COMMAND_BL_GO_TO_ADDR 
        data_buf[2] = word_to_byte(go_address,1,1) 
        data_buf[3] = word_to_byte(go_address,2,1) 
        data_buf[4] = word_to_byte(go_address,3,1) 
        data_buf[5] = word_to_byte(go_address,4,1) 
        crc32       = get_crc(data_buf,COMMAND_BL_GO_TO_ADDR_LEN-4) 
        data_buf[6] = word_to_byte(crc32,1,1) 
        data_buf[7] = word_to_byte(crc32,2,1) 
        data_buf[8] = word_to_byte(crc32,3,1) 
        data_buf[9] = word_to_byte(crc32,4,1) 

        Write_to_serial_port(data_buf[0],1)
        
        for i in data_buf[1:COMMAND_BL_GO_TO_ADDR_LEN]:
            Write_to_serial_port(i,COMMAND_BL_GO_TO_ADDR_LEN-1)
        
        ret_value = read_bootloader_reply(data_buf[1])
        
    elif(command == 6):
        print("\n   This command is not supported")
    elif(command == 7):
        print("\n   Command == > BL_FLASH_ERASE")
        data_buf[0] = COMMAND_BL_FLASH_ERASE_LEN-1 
        data_buf[1] = COMMAND_BL_FLASH_ERASE
        sector_num = input("\n   Enter sector number(0-7 or 0xFF) here :")
        sector_num = int(sector_num, 16)
        nsec = 0
		
        if(sector_num != 0xff):
            nsec=int(input("\n   Enter number of sectors to erase(max 8) here :"))
        
        data_buf[2]= sector_num 
        data_buf[3]= nsec 

        crc32       = get_crc(data_buf,COMMAND_BL_FLASH_ERASE_LEN-4) 
        data_buf[4] = word_to_byte(crc32,1,1) 
        data_buf[5] = word_to_byte(crc32,2,1) 
        data_buf[6] = word_to_byte(crc32,3,1) 
        data_buf[7] = word_to_byte(crc32,4,1) 

        Write_to_serial_port(data_buf[0],1)
        
        for i in data_buf[1:COMMAND_BL_FLASH_ERASE_LEN]:
            Write_to_serial_port(i,COMMAND_BL_FLASH_ERASE_LEN-1)
        
        ret_value = read_bootloader_reply(data_buf[1])
        
    elif(command == 8):
        print("\n   Command == > BL_MEM_WRITE")
        bytes_remaining=0
        t_len_of_file=0
        bytes_so_far_sent = 0
        len_to_read=0
        base_mem_address=0

        data_buf[1] = COMMAND_BL_MEM_WRITE

        #First get the total number of bytes in the .bin file.
        t_len_of_file =calc_file_len()

        #keep opening the file
        open_the_file()

        bytes_remaining = t_len_of_file - bytes_so_far_sent

        base_mem_address = input("\n   Enter the memory write address here :")
        base_mem_address = int(base_mem_address, 16)
        global mem_write_active
        while(bytes_remaining):
            mem_write_active=1
            if(bytes_remaining >= 128):
                len_to_read = 128
            else:
                len_to_read = bytes_remaining
            #get the bytes in to buffer by reading file
            for x in range(len_to_read):
                file_read_value = bin_file.read(1)
                file_read_value = bytearray(file_read_value)
                data_buf[7+x]= int(file_read_value[0])
            #read_the_file(&data_buf[7],len_to_read) 
            #print("\n   base mem address = \n",base_mem_address, hex(base_mem_address)) 

            #populate base mem address
            data_buf[2] = word_to_byte(base_mem_address,1,1)
            data_buf[3] = word_to_byte(base_mem_address,2,1)
            data_buf[4] = word_to_byte(base_mem_address,3,1)
            data_buf[5] = word_to_byte(base_mem_address,4,1)

            data_buf[6] = len_to_read

            #/* 1 byte len + 1 byte command code + 4 byte mem base address
            #* 1 byte payload len + len_to_read is amount of bytes read from file + 4 byte CRC
            #*/
            mem_write_cmd_total_len = COMMAND_BL_MEM_WRITE_LEN+len_to_read

            #first field is "len_to_follow"
            data_buf[0] =mem_write_cmd_total_len-1

            crc32       = get_crc(data_buf,mem_write_cmd_total_len-4)
            data_buf[7+len_to_read] = word_to_byte(crc32,1,1)
            data_buf[8+len_to_read] = word_to_byte(crc32,2,1)
            data_buf[9+len_to_read] = word_to_byte(crc32,3,1)
            data_buf[10+len_to_read] = word_to_byte(crc32,4,1)

            #update base mem address for the next loop
            base_mem_address+=len_to_read

            Write_to_serial_port(data_buf[0],1)
        
            for i in data_buf[1:mem_write_cmd_total_len]:
                Write_to_serial_port(i,mem_write_cmd_total_len-1)

            bytes_so_far_sent+=len_to_read
            bytes_remaining = t_len_of_file - bytes_so_far_sent
            print("\n   bytes_so_far_sent:{0} -- bytes_remaining:{1}\n".format(bytes_so_far_sent,bytes_remaining)) 
        
            ret_value = read_bootloader_reply(data_buf[1])
        mem_write_active=0

            
    
    elif(command == 9):
        print("\n   Command == > BL_EN_R_W_PROTECT")
        total_sector = int(input("\n   How many sectors do you want to protect ?: "))
        sector_numbers = [0,0,0,0,0,0,0,0]
        sector_details=0
        for x in range(total_sector):
            sector_numbers[x]=int(input("\n   Enter sector number[{0}]: ".format(x+1) ))
            sector_details = sector_details | (1 << sector_numbers[x])

        #print("Sector details",sector_details)
        print("\n   Mode:Flash sectors Write Protection: 1")
        print("\n   Mode:Flash sectors Read/Write Protection: 2")
        mode=input("\n   Enter Sector Protection Mode(1 or 2 ):")
        mode = int(mode)
        if(mode != 2 and mode != 1):
            printf("\n   Invalid option : Command Dropped")
            return
        if(mode == 2):
            print("\n   This feature is currently not supported !") 
            return

        data_buf[0] = COMMAND_BL_EN_R_W_PROTECT_LEN-1 
        data_buf[1] = COMMAND_BL_EN_R_W_PROTECT 
        data_buf[2] = sector_details 
        data_buf[3] = mode 
        crc32       = get_crc(data_buf,COMMAND_BL_EN_R_W_PROTECT_LEN-4) 
        data_buf[4] = word_to_byte(crc32,1,1) 
        data_buf[5] = word_to_byte(crc32,2,1) 
        data_buf[6] = word_to_byte(crc32,3,1) 
        data_buf[7] = word_to_byte(crc32,4,1) 

        Write_to_serial_port(data_buf[0],1)
        
        for i in data_buf[1:COMMAND_BL_EN_R_W_PROTECT_LEN]:
            Write_to_serial_port(i,COMMAND_BL_EN_R_W_PROTECT_LEN-1)
        
        ret_value = read_bootloader_reply(data_buf[1])
            
        
    elif(command == 10):
        print("\n   Command == > COMMAND_BL_MEM_READ")
        print("\n   This command is not supported")
    elif(command == 11):
        print("\n   Command == > COMMAND_BL_READ_SECTOR_P_STATUS")
        data_buf[0] = COMMAND_BL_READ_SECTOR_P_STATUS_LEN-1 
        data_buf[1] = COMMAND_BL_READ_SECTOR_P_STATUS 

        crc32       = get_crc(data_buf,COMMAND_BL_READ_SECTOR_P_STATUS_LEN-4) 
        data_buf[2] = word_to_byte(crc32,1,1) 
        data_buf[3] = word_to_byte(crc32,2,1) 
        data_buf[4] = word_to_byte(crc32,3,1) 
        data_buf[5] = word_to_byte(crc32,4,1) 

        Write_to_serial_port(data_buf[0],1)
        
        for i in data_buf[1:COMMAND_BL_READ_SECTOR_P_STATUS_LEN]:
            Write_to_serial_port(i,COMMAND_BL_READ_SECTOR_P_STATUS_LEN-1)
        
        ret_value = read_bootloader_reply(data_buf[1])

    elif(command == 12):
        print("\n   Command == > COMMAND_OTP_READ")
        print("\n   This command is not supported")
    elif(command == 13):
        print("\n   Command == > COMMAND_BL_DIS_R_W_PROTECT")
        data_buf[0] = COMMAND_BL_DIS_R_W_PROTECT_LEN-1 
        data_buf[1] = COMMAND_BL_DIS_R_W_PROTECT 
        crc32       = get_crc(data_buf,COMMAND_BL_DIS_R_W_PROTECT_LEN-4) 
        data_buf[2] = word_to_byte(crc32,1,1) 
        data_buf[3] = word_to_byte(crc32,2,1) 
        data_buf[4] = word_to_byte(crc32,3,1) 
        data_buf[5] = word_to_byte(crc32,4,1) 

        Write_to_serial_port(data_buf[0],1)
        
        for i in data_buf[1:COMMAND_BL_DIS_R_W_PROTECT_LEN]:
            Write_to_serial_port(i,COMMAND_BL_DIS_R_W_PROTECT_LEN-1)
        
        ret_value = read_bootloader_reply(data_buf[1])
        
    elif(command == 14):
        print("\n   Command == > COMMAND_BL_MY_NEW_COMMAND ")
        data_buf[0] = COMMAND_BL_MY_NEW_COMMAND_LEN-1 
        data_buf[1] = COMMAND_BL_MY_NEW_COMMAND 
        crc32       = get_crc(data_buf,COMMAND_BL_MY_NEW_COMMAND_LEN-4) 
        data_buf[2] = word_to_byte(crc32,1,1) 
        data_buf[3] = word_to_byte(crc32,2,1) 
        data_buf[4] = word_to_byte(crc32,3,1) 
        data_buf[5] = word_to_byte(crc32,4,1) 

        Write_to_serial_port(data_buf[0],1)
        
        for i in data_buf[1:COMMAND_BL_MY_NEW_COMMAND_LEN]:
            Write_to_serial_port(i,COMMAND_BL_MY_NEW_COMMAND_LEN-1)
        
        ret_value = read_bootloader_reply(data_buf[1])
    else:
        print("\n   Please input valid command code\n")
        return

    if ret_value == -2 :
        print("\n   TimeOut : No response from the bootloader")
        print("\n   Reset the board and Try Again !")
        return

def read_bootloader_reply(command_code):
    #ack=[0,0]
    len_to_follow=0 
    ret = -2 

    #read_serial_port(ack,2)
    #ack = ser.read(2)
    ack=read_serial_port(2)
    if(len(ack) ):
        a_array=bytearray(ack)
        #print("read uart:",ack) 
        if (a_array[0]== 0xA5):
            #CRC of last command was good .. received ACK and "len to follow"
            len_to_follow=a_array[1]
            print("\n   CRC : SUCCESS Len :",len_to_follow)
            #print("command_code:",hex(command_code))
            if (command_code) == COMMAND_BL_GET_VER :
                process_COMMAND_BL_GET_VER(len_to_follow)
                
            elif(command_code) == COMMAND_BL_GET_HELP:
                process_COMMAND_BL_GET_HELP(len_to_follow)
                
            elif(command_code) == COMMAND_BL_GET_CID:
                process_COMMAND_BL_GET_CID(len_to_follow)
                
            elif(command_code) == COMMAND_BL_GET_RDP_STATUS:
                process_COMMAND_BL_GET_RDP_STATUS(len_to_follow)
                
            elif(command_code) == COMMAND_BL_GO_TO_ADDR:
                process_COMMAND_BL_GO_TO_ADDR(len_to_follow)
                
            elif(command_code) == COMMAND_BL_FLASH_ERASE:
                process_COMMAND_BL_FLASH_ERASE(len_to_follow)
                
            elif(command_code) == COMMAND_BL_MEM_WRITE:
                process_COMMAND_BL_MEM_WRITE(len_to_follow)
                
            elif(command_code) == COMMAND_BL_READ_SECTOR_P_STATUS:
                process_COMMAND_BL_READ_SECTOR_STATUS(len_to_follow)
                
            elif(command_code) == COMMAND_BL_EN_R_W_PROTECT:
                process_COMMAND_BL_EN_R_W_PROTECT(len_to_follow)
                
            elif(command_code) == COMMAND_BL_DIS_R_W_PROTECT:
                process_COMMAND_BL_DIS_R_W_PROTECT(len_to_follow)
                
            elif(command_code) == COMMAND_BL_MY_NEW_COMMAND:
                process_COMMAND_BL_MY_NEW_COMMAND(len_to_follow)
                
            else:
                print("\n   Invalid command code\n")
                
            ret = 0
         
        elif a_array[0] == 0x7F:
            #CRC of last command was bad .. received NACK
            print("\n   CRC: FAIL \n")
            ret= -1
    else:
        print("\n   Timeout : Bootloader not responding")
        
    return ret
                

#----------------------------- Ask Menu implementation----------------------------------------


name = input("Enter the Port Name of your device(Ex: COM3):")
ret = 0
ret=Serial_Port_Configuration(name)
if(ret < 0):
    decode_menu_command_code(0)
    
  
  
while True:
    print("\n +==========================================+")
    print(" |               Menu                       |")
    print(" |         STM32F4 BootLoader v1            |")
    print(" +==========================================+")

  
    
    print("\n   Which BL command do you want to send ??\n")
    print("   BL_GET_VER                            --> 1")
    print("   BL_GET_HLP                            --> 2")
    print("   BL_GET_CID                            --> 3")
    print("   BL_GET_RDP_STATUS                     --> 4")
    print("   BL_GO_TO_ADDR                         --> 5")
    print("   BL_FLASH_MASS_ERASE                   --> 6")
    print("   BL_FLASH_ERASE                        --> 7")
    print("   BL_MEM_WRITE                          --> 8")
    print("   BL_EN_R_W_PROTECT                     --> 9")
    print("   BL_MEM_READ                           --> 10")
    print("   BL_READ_SECTOR_P_STATUS               --> 11")
    print("   BL_OTP_READ                           --> 12")
    print("   BL_DIS_R_W_PROTECT                    --> 13")
    print("   BL_MY_NEW_COMMAND                     --> 14")
    print("   MENU_EXIT                             --> 0")

    #command_code = int(input("\n   Type the command code here :") )

    command_code = input("\n   Type the command code here :")

    if(not command_code.isdigit()):
        print("\n   Please Input valid code shown above")
    else:
        decode_menu_command_code(int(command_code))

    input("\n   Press any key to continue  :")
    purge_serial_port()
    

def check_flash_status():
    pass

def protection_type():
    pass